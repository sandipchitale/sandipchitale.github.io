<!DOCTYPE html>
<html>
<head>
    <title>Encased Intersection Gimbal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #888;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }

        h2 {
            margin: 0;
            color: #ccc;
        }

        p {
            margin: 5px;
            font-size: 0.9em;
        }

        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 240px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            color: white;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }

        button:hover {
            background: #555;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .highlight {
            color: #00ddee;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="controls">
    <label for="phaseSlider">Lag: <span id="phaseVal" class="highlight">0</span> degrees</label>
    <input type="range" id="phaseSlider" min="0" max="180" value="0" step="1">

    <label style="margin-top:15px">Flip Black Shape:</label>
    <button id="flipBtn">Flip (Mirror)</button>

    <button id="toggleBtn" style="background: #2a662a; border-color:#484;">Pause Animation</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. LIGHTING
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x00ddee, 1.0);
    backLight.position.set(-5, -5, -5);
    scene.add(backLight);

    // 3. MATERIALS & DIMENSIONS
    const frameRadius = 4.0;
    const splitGap = 0.12;
    const splitTubeRadius = 0.08;
    const outerClampRadius = 0.36;

    const shapeRadius = frameRadius - 0.1;
    const shapeThickness = 0.15; // Slightly thicker for visibility
    const centerHoleRadius = 0.35; // Size of the central "ark" cutout

    // Gap Angle (How much material to remove at intersection)
    const intersectionGap = Math.PI / 36;

    const matWhite = new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.2});
    const matYinWhite = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});
    const matYangBlack = new THREE.MeshStandardMaterial({color: 0x111111, side: THREE.DoubleSide}); // Dark grey to be visible against bg
    const matSilver = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.9, roughness: 0.1});

    const matGlass = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.95,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });

    // 4. GEOMETRY FUNCTIONS

    // A. The "Gapped" Frame
    // A. The "Gapped" Frame (Grooved Torus via Lathe)
    function createGappedFrame(radius) {
        const group = new THREE.Group();

        // Define the profile for LatheGeometry
        // The Lathe revolves around the Y axis.
        // The profile is defined in the XY plane.
        // X corresponds to the radial distance from the center of the torus.
        // Y corresponds to the vertical thickness of the torus.
        
        const R_tube = outerClampRadius; // 0.36
        const grooveWidth = 0.14;
        const grooveDepth = 0.15; // X coordinate of the back wall (relative to tube center)
        const h = grooveWidth / 2;
        
        // Center of the tube profile is at x = radius
        const cx = radius;
        
        // Calculate intersection X relative to tube center
        // x^2 + h^2 = R_tube^2 => x = -sqrt(R^2 - h^2) (Inner side)
        const xi = -Math.sqrt(R_tube * R_tube - h * h);
        
        const points = [];
        
        // 1. Start at Top-Inner Lip
        points.push(new THREE.Vector2(cx + xi, h));
        
        // 2. Go IN to Back Wall Top
        points.push(new THREE.Vector2(cx + grooveDepth, h));
        
        // 3. Go DOWN to Back Wall Bottom
        points.push(new THREE.Vector2(cx + grooveDepth, -h));
        
        // 4. Go OUT to Bottom-Inner Lip
        points.push(new THREE.Vector2(cx + xi, -h));
        
        // 5. Arc from Bottom-Inner Lip to Top-Inner Lip (Counter-Clockwise)
        // We need to generate points along the circle.
        const startAngle = Math.atan2(-h, xi);
        const endAngle = Math.atan2(h, xi);
        
        // We want to go from startAngle to endAngle the LONG way (Counter-Clockwise).
        // startAngle is approx -168 deg (-2.9 rad).
        // endAngle is approx 168 deg (2.9 rad).
        // To go CCW, we go -2.9 -> ... -> 0 -> ... -> 2.9.
        // Wait, atan2 returns -PI to PI.
        // If we go CCW from -2.9 to 2.9, we cross 0. That's the RIGHT side (Outer side).
        // That is correct. The "Inner" side is the groove (Left side).
        
        const segments = 32;
        for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            // Ensure we go the long way if needed? 
            // -2.9 to 2.9 is 5.8 radians. That's the long way.
            // The short way (across the gap) would be 2.9 to -2.9 (crossing PI).
            // So simple lerp works.
            const angle = startAngle + t * (endAngle - startAngle);
            const px = cx + R_tube * Math.cos(angle);
            const py = R_tube * Math.sin(angle);
            points.push(new THREE.Vector2(px, py));
        }
        
        // Create LatheGeometry
        const geometry = new THREE.LatheGeometry(points, 128); // 128 segments for smooth torus
        
        // Lathe creates a torus with axis Y.
        // Standard TorusGeometry has axis Z.
        // We need to rotate X by 90 deg to match Torus orientation (Hole along Z).
        geometry.rotateX(Math.PI / 2);

        const mesh = new THREE.Mesh(geometry, matGlass);
        group.add(mesh);

        return group;
    }

    // B. The Safe Yin/Yang Shape (Calculated Contour)
    function createTeardropShape(R, r_hole) {
        const shape = new THREE.Shape();
        const Rs = R / 2; // Radius of small circles
        const rf = 0.15; // Fillet radius

        // Helper to find fillet center and angles
        // Solves intersection of two circles centered at (0, y1) and (0, 0) with radii d1 and d2
        // intersectionSign: -1 for Left (Top), 1 for Right (Bottom)
        function getFilletData(y1, d1, d2, intersectionSign) {
            // Solve for fillet center (fx, fy)
            // x^2 + (y - y1)^2 = d1^2
            // x^2 + y^2 = d2^2
            
            const fy = (y1 * y1 - d1 * d1 + d2 * d2) / (2 * y1);
            const fx = intersectionSign * Math.sqrt(d2 * d2 - fy * fy);
            
            // Angles from centers to fillet center
            const angleFromC1 = Math.atan2(fy - y1, fx);
            const angleFromC2 = Math.atan2(fy, fx);
            
            return { fx, fy, angleFromC1, angleFromC2 };
        }

        // 1. Top Fillet (Between Top S-Curve and Hole)
        // Top S-Curve: Center (0, Rs). Material Inside. Tangent: Rs - rf.
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf.
        // Intersection is on the Left (-1).
        const topFillet = getFilletData(Rs, Rs - rf, r_hole + rf, -1);

        // 2. Bottom Fillet (Between Hole and Bottom S-Curve)
        // Bottom S-Curve: Center (0, -Rs). Material Outside (Scoop). Tangent: Rs + rf (External).
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf (External).
        // Intersection is on the Right (1).
        const botFillet = getFilletData(-Rs, Rs + rf, r_hole + rf, 1);

        // --- DRAW PATH ---

        // 1. Outer Arc (Right Semicircle)
        // From Bottom (0, -R) to Top (0, R)
        shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);

        // 2. Top S-Curve (Head)
        // From (0, R) to Top Fillet Start
        // Center (0, Rs), Radius Rs.
        // Start: PI/2. End: angleFromC1 of top fillet.
        shape.absarc(0, Rs, Rs, Math.PI / 2, topFillet.angleFromC1, false);

        // 3. Top Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC1 (Contact with S-curve).
        // End: angleFromC2 + PI (Contact with Hole).
        // CCW (false).
        shape.absarc(topFillet.fx, topFillet.fy, rf, topFillet.angleFromC1, topFillet.angleFromC2 + Math.PI, false);

        // 4. Center Cutout Arc (Hole)
        // From Top Fillet End to Bottom Fillet Start.
        // Center (0,0), Radius r_hole.
        // Start: topFillet.angleFromC2.
        // End: botFillet.angleFromC2.
        // CW (true).
        shape.absarc(0, 0, r_hole, topFillet.angleFromC2, botFillet.angleFromC2, true);

        // 5. Bottom Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC2 + PI (Contact with Hole).
        // End: angleFromC1 + PI (Contact with S-curve).
        // CCW (false).
        shape.absarc(botFillet.fx, botFillet.fy, rf, botFillet.angleFromC2 + Math.PI, botFillet.angleFromC1 + Math.PI, false);

        // 6. Bottom S-Curve (Tail Scoop)
        // From Bottom Fillet End to (0, -R).
        // Center (0, -Rs), Radius Rs.
        // Start: botFillet.angleFromC1.
        // End: -PI/2.
        // CW (true).
        shape.absarc(0, -Rs, Rs, botFillet.angleFromC1, -Math.PI / 2, true);

        // 7. The "Dot" (Hole in the Head)
        // Center: (0, Rs) -> Center of the Top S-Curve
        // Radius: Let's say Rs / 3.5 for a good proportion
        const dotRadius = Rs / 3.5;
        const dotPath = new THREE.Path();
        dotPath.absarc(0, Rs, dotRadius, 0, Math.PI * 2, true); // CW for hole
        shape.holes.push(dotPath);

        const geo = new THREE.ExtrudeGeometry(shape, {depth: shapeThickness, bevelEnabled: false});
        geo.translate(0, 0, -shapeThickness / 2);
        return new THREE.Mesh(geo, null);
    }

    // C. The Bearings
    function createBearingArc(radius, count) {
        const group = new THREE.Group();
        const bearingGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 16);
        bearingGeo.rotateX(Math.PI / 2);
        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;

        for (let i = 0; i < count; i++) {
            const t = i / (count - 1);
            const angle = startAngle + t * (endAngle - startAngle);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const dist = Math.sqrt(x * x + y * y);
            if (dist > centerHoleRadius + 0.3) {
                const bearing = new THREE.Mesh(bearingGeo, matSilver);
                bearing.position.set(x, y, 0);
                bearing.rotation.z = angle;
                if (i > 0 && i < count - 1) {
                    group.add(bearing);
                }
            }
        }
        return group;
    }

    // 5. BUILD SCENE

    // --- SYSTEM P (Vertical) ---
    const frameP = createGappedFrame(frameRadius);
    frameP.rotation.y = Math.PI / 2;
    scene.add(frameP);

    const rotorP = new THREE.Group();
    const shapeP = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeP.material = matYinWhite;
    rotorP.add(shapeP);
    rotorP.add(createBearingArc(frameRadius, 9));
    rotorP.rotation.y = Math.PI / 2;
    scene.add(rotorP);

    // --- SYSTEM O (Horizontal) ---
    const frameO = createGappedFrame(frameRadius);
    frameO.rotation.x = Math.PI / 2;
    frameO.rotation.z = Math.PI / 2;
    scene.add(frameO);

    const rotorO = new THREE.Group();
    const shapeO = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeO.material = matYangBlack;
    rotorO.add(shapeO);
    rotorO.add(createBearingArc(frameRadius, 9));

    rotorO.rotation.x = Math.PI / 2;
    rotorO.rotation.z = Math.PI / 2;
    scene.add(rotorO);

    // 6. ANIMATION
    let time = 0;
    let isPlaying = true;
    let isFlipped = false;
    let lagDegrees = 0;
    let lagRadians = 0;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            time += 0.015;
            rotorP.rotation.z = time;
            rotorO.rotation.z = (time + lagRadians) + Math.PI / 2;
        }
        renderer.render(scene, camera);
    }

    animate();

    // 7. UI
    const slider = document.getElementById('phaseSlider');
    const valLabel = document.getElementById('phaseVal');

    slider.addEventListener('input', (e) => {
        lagDegrees = parseInt(e.target.value);
        lagRadians = lagDegrees * (Math.PI / 180);
        valLabel.textContent = lagDegrees;

        if (!isPlaying) {
            rotorO.rotation.z = (rotorP.rotation.z + lagRadians) + Math.PI / 2;
            renderer.render(scene, camera);
        }
    });

    document.getElementById('toggleBtn').addEventListener('click', (e) => {
        isPlaying = !isPlaying;
        e.target.textContent = isPlaying ? "Pause Animation" : "Resume Animation";
    });

    document.getElementById('flipBtn').addEventListener('click', (e) => {
        isFlipped = !isFlipped;
        shapeO.scale.y = isFlipped ? -1 : 1;
        e.target.textContent = isFlipped ? "Un-Flip (Standard)" : "Flip (Mirror)";
        if (!isPlaying) renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>

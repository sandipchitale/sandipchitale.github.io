<!DOCTYPE html>
<html>
<head>
    <title>Encased Intersection Gimbal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #888;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }

        h2 {
            margin: 0;
            color: #ccc;
        }

        p {
            margin: 5px;
            font-size: 0.9em;
        }

        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 240px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            color: white;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }

        button:hover {
            background: #555;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .highlight {
            color: #00ddee;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="info">
    <h2>Encased Intersection Gimbal</h2>
    <p>Fixed: Valid Geometry â€¢ Central Clearance Arcs</p>
</div>

<div id="controls">
    <label for="phaseSlider">Lag: <span id="phaseVal" class="highlight">0</span> degrees</label>
    <input type="range" id="phaseSlider" min="0" max="180" value="0" step="1">

    <label style="margin-top:15px">Flip Black Shape:</label>
    <button id="flipBtn">Flip (Mirror)</button>

    <button id="toggleBtn" style="background: #2a662a; border-color:#484;">Pause Animation</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. LIGHTING
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x00ddee, 1.0);
    backLight.position.set(-5, -5, -5);
    scene.add(backLight);

    // 3. MATERIALS & DIMENSIONS
    const frameRadius = 4.0;
    const splitGap = 0.12;
    const splitTubeRadius = 0.08;
    const outerClampRadius = 0.36;

    const shapeRadius = frameRadius - 0.1;
    const shapeThickness = 0.15; // Slightly thicker for visibility
    const centerHoleRadius = 0.35; // Size of the central "ark" cutout

    // Gap Angle (How much material to remove at intersection)
    const intersectionGap = Math.PI / 36;

    const matWhite = new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.2});
    const matYinWhite = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});
    const matYangBlack = new THREE.MeshStandardMaterial({color: 0x111111, side: THREE.DoubleSide}); // Dark grey to be visible against bg
    const matSilver = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.9, roughness: 0.1});

    const matGlass = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.95,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });

    // 4. GEOMETRY FUNCTIONS

    // A. The "Gapped" Frame
    function createGappedFrame(radius) {
        const group = new THREE.Group();

        // Internal Split Rails
        const arcLength = Math.PI - intersectionGap;
        const start1 = intersectionGap / 2;
        const start2 = Math.PI + intersectionGap / 2;

        function buildRail(zOffset) {
            const railGroup = new THREE.Group();
            const geo1 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo1.rotateZ(start1);
            const mesh1 = new THREE.Mesh(geo1, matWhite);
            mesh1.position.z = zOffset;
            railGroup.add(mesh1);

            const geo2 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo2.rotateZ(start2);
            const mesh2 = new THREE.Mesh(geo2, matWhite);
            mesh2.position.z = zOffset;
            railGroup.add(mesh2);
            return railGroup;
        }

        group.add(buildRail(splitGap / 2 + splitTubeRadius / 2));
        group.add(buildRail(-(splitGap / 2 + splitTubeRadius / 2)));

        // Outer Wrapper (Glass)
        const glassGeo = new THREE.TorusGeometry(radius, outerClampRadius, 24, 100, Math.PI * 2);
        const glassMesh = new THREE.Mesh(glassGeo, matGlass);
        group.add(glassMesh);

        return group;
    }

    // B. The Safe Yin/Yang Shape (Calculated Contour)
    function createTeardropShape(R, r_hole) {
        const shape = new THREE.Shape();

        // Helper: Intersection of Small Circle (S-curve) and Hole Circle
        // S-Circle Equation: x^2 + (y - Ry_center)^2 = (R/2)^2
        // Hole Equation: x^2 + y^2 = r_hole^2

        const Rs = R / 2; // Radius of small circles

        // 1. Top Intersection (Top S-Curve & Hole)
        // Center (0, Rs). Equation: x^2 + y^2 - 2*y*Rs + Rs^2 = Rs^2  => x^2 + y^2 - R*y = 0
        // Sub hole: r_hole^2 - R*y = 0 => y = r_hole^2 / R
        const y_top = (r_hole * r_hole) / R;
        const x_top = -Math.sqrt(r_hole * r_hole - y_top * y_top); // Negative because Top S bulges Left

        // Angle on Top Small Circle (Center 0, Rs)
        const angleTopEnd = Math.atan2(y_top - Rs, x_top - 0);

        // 2. Bottom Intersection (Bottom S-Curve & Hole)
        // Center (0, -Rs). y = -r_hole^2 / R
        const y_bot = -(r_hole * r_hole) / R;
        const x_bot = Math.sqrt(r_hole * r_hole - y_bot * y_bot); // Positive because Bottom S bulges Right (scoop)

        // Angle on Bottom Small Circle (Center 0, -Rs)
        const angleBotStart = Math.atan2(y_bot - (-Rs), x_bot - 0);

        // 3. Angles on Hole Circle (Center 0,0)
        const angleHoleStart = Math.atan2(y_top, x_top);
        const angleHoleEnd = Math.atan2(y_bot, x_bot);

        // --- DRAW PATH ---

        // 1. Outer Arc (Right Semicircle)
        // From Bottom (0, -R) to Top (0, R)
        shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);

        // 2. Top S-Curve (Head)
        // From (0, R) to Top Intersection
        // Center (0, Rs), Radius Rs.
        // Standard starts at PI/2 (Top). Ends at angleTopEnd. CCW (false).
        shape.absarc(0, Rs, Rs, Math.PI / 2, angleTopEnd, false);

        // 3. Center Cutout Arc
        // Connects Top Intersection to Bottom Intersection via the Hole boundary.
        // We keep "Solid on Left", so we trace the hole Clockwise (true).
        shape.absarc(0, 0, r_hole, angleHoleStart, angleHoleEnd, true);

        // 4. Bottom S-Curve (Tail Scoop)
        // From Bottom Intersection to (0, -R).
        // Center (0, -Rs), Radius Rs.
        // Standard ends at -PI/2 (Bottom). Starts at angleBotStart. CW (true) to form scoop.
        shape.absarc(0, -Rs, Rs, angleBotStart, -Math.PI / 2, true);

        const geo = new THREE.ExtrudeGeometry(shape, {depth: shapeThickness, bevelEnabled: false});
        geo.translate(0, 0, -shapeThickness / 2);
        return new THREE.Mesh(geo, null);
    }

    // C. The Bearings
    function createBearingArc(radius, count) {
        const group = new THREE.Group();
        const bearingGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 16);
        bearingGeo.rotateX(Math.PI / 2);
        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;

        for (let i = 0; i < count; i++) {
            const t = i / (count - 1);
            const angle = startAngle + t * (endAngle - startAngle);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const dist = Math.sqrt(x * x + y * y);
            if (dist > centerHoleRadius + 0.3) {
                const bearing = new THREE.Mesh(bearingGeo, matSilver);
                bearing.position.set(x, y, 0);
                bearing.rotation.z = angle;
                if (i > 0 && i < count - 1) {
                    group.add(bearing);
                }
            }
        }
        return group;
    }

    // 5. BUILD SCENE

    // --- SYSTEM P (Vertical) ---
    const frameP = createGappedFrame(frameRadius);
    frameP.rotation.y = Math.PI / 2;
    scene.add(frameP);

    const rotorP = new THREE.Group();
    const shapeP = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeP.material = matYinWhite;
    rotorP.add(shapeP);
    rotorP.add(createBearingArc(frameRadius, 9));
    rotorP.rotation.y = Math.PI / 2;
    scene.add(rotorP);

    // --- SYSTEM O (Horizontal) ---
    const frameO = createGappedFrame(frameRadius);
    frameO.rotation.x = Math.PI / 2;
    frameO.rotation.z = Math.PI / 2;
    scene.add(frameO);

    const rotorO = new THREE.Group();
    const shapeO = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeO.material = matYangBlack;
    rotorO.add(shapeO);
    rotorO.add(createBearingArc(frameRadius, 9));

    rotorO.rotation.x = Math.PI / 2;
    rotorO.rotation.z = Math.PI / 2;
    scene.add(rotorO);

    // 6. ANIMATION
    let time = 0;
    let isPlaying = true;
    let isFlipped = false;
    let lagDegrees = 0;
    let lagRadians = 0;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            time += 0.015;
            rotorP.rotation.z = time;
            rotorO.rotation.z = (time + lagRadians) + Math.PI / 2;
        }
        renderer.render(scene, camera);
    }

    animate();

    // 7. UI
    const slider = document.getElementById('phaseSlider');
    const valLabel = document.getElementById('phaseVal');

    slider.addEventListener('input', (e) => {
        lagDegrees = parseInt(e.target.value);
        lagRadians = lagDegrees * (Math.PI / 180);
        valLabel.textContent = lagDegrees;

        if (!isPlaying) {
            rotorO.rotation.z = (rotorP.rotation.z + lagRadians) + Math.PI / 2;
            renderer.render(scene, camera);
        }
    });

    document.getElementById('toggleBtn').addEventListener('click', (e) => {
        isPlaying = !isPlaying;
        e.target.textContent = isPlaying ? "Pause Animation" : "Resume Animation";
    });

    document.getElementById('flipBtn').addEventListener('click', (e) => {
        isFlipped = !isFlipped;
        shapeO.scale.y = isFlipped ? -1 : 1;
        e.target.textContent = isFlipped ? "Un-Flip (Standard)" : "Flip (Mirror)";
        if (!isPlaying) renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>

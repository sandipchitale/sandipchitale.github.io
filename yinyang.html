<!DOCTYPE html>
<html>
<head>
    <title>Encased Intersection Gimbal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #888;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }

        h2 {
            margin: 0;
            color: #ccc;
        }

        p {
            margin: 5px;
            font-size: 0.9em;
        }

        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 240px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            color: white;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }

        button:hover {
            background: #555;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .highlight {
            color: #00ddee;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="info">
    <h2>Encased Intersection Gimbal</h2>
    <p>Fixed: Valid Geometry â€¢ Central Clearance Arcs</p>
</div>

<div id="controls">
    <label for="phaseSlider">Lag: <span id="phaseVal" class="highlight">0</span> degrees</label>
    <input type="range" id="phaseSlider" min="0" max="180" value="0" step="1">

    <label style="margin-top:15px">Flip Black Shape:</label>
    <button id="flipBtn">Flip (Mirror)</button>

    <button id="toggleBtn" style="background: #2a662a; border-color:#484;">Pause Animation</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. LIGHTING
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x00ddee, 1.0);
    backLight.position.set(-5, -5, -5);
    scene.add(backLight);

    // 3. MATERIALS & DIMENSIONS
    const frameRadius = 4.0;
    const splitGap = 0.12;
    const splitTubeRadius = 0.08;
    const outerClampRadius = 0.36;

    const shapeRadius = frameRadius - 0.1;
    const shapeThickness = 0.15; // Slightly thicker for visibility
    const centerHoleRadius = 0.35; // Size of the central "ark" cutout

    // Gap Angle (How much material to remove at intersection)
    const intersectionGap = Math.PI / 36;

    const matWhite = new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.2});
    const matYinWhite = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});
    const matYangBlack = new THREE.MeshStandardMaterial({color: 0x111111, side: THREE.DoubleSide}); // Dark grey to be visible against bg
    const matSilver = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.9, roughness: 0.1});

    const matGlass = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.95,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });

    // 4. GEOMETRY FUNCTIONS

    // A. The "Gapped" Frame
    function createGappedFrame(radius) {
        const group = new THREE.Group();

        // Internal Split Rails
        const arcLength = Math.PI - intersectionGap;
        const start1 = intersectionGap / 2;
        const start2 = Math.PI + intersectionGap / 2;

        function buildRail(zOffset) {
            const railGroup = new THREE.Group();
            const geo1 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo1.rotateZ(start1);
            const mesh1 = new THREE.Mesh(geo1, matWhite);
            mesh1.position.z = zOffset;
            railGroup.add(mesh1);

            const geo2 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo2.rotateZ(start2);
            const mesh2 = new THREE.Mesh(geo2, matWhite);
            mesh2.position.z = zOffset;
            railGroup.add(mesh2);
            return railGroup;
        }

        group.add(buildRail(splitGap / 2 + splitTubeRadius / 2));
        group.add(buildRail(-(splitGap / 2 + splitTubeRadius / 2)));

        // Outer Wrapper (Glass)
        const glassGeo = new THREE.TorusGeometry(radius, outerClampRadius, 24, 100, Math.PI * 2);
        const glassMesh = new THREE.Mesh(glassGeo, matGlass);
        group.add(glassMesh);

        return group;
    }

    // B. The Safe Yin/Yang Shape (Calculated Contour)
    function createTeardropShape(R, r_hole) {
        const shape = new THREE.Shape();
        const Rs = R / 2; // Radius of small circles
        const rf = 0.15; // Fillet radius

        // Helper to find fillet center and angles
        // Solves intersection of two circles centered at (0, y1) and (0, 0) with radii d1 and d2
        // intersectionSign: -1 for Left (Top), 1 for Right (Bottom)
        function getFilletData(y1, d1, d2, intersectionSign) {
            // Solve for fillet center (fx, fy)
            // x^2 + (y - y1)^2 = d1^2
            // x^2 + y^2 = d2^2
            
            const fy = (y1 * y1 - d1 * d1 + d2 * d2) / (2 * y1);
            const fx = intersectionSign * Math.sqrt(d2 * d2 - fy * fy);
            
            // Angles from centers to fillet center
            const angleFromC1 = Math.atan2(fy - y1, fx);
            const angleFromC2 = Math.atan2(fy, fx);
            
            return { fx, fy, angleFromC1, angleFromC2 };
        }

        // 1. Top Fillet (Between Top S-Curve and Hole)
        // Top S-Curve: Center (0, Rs). Material Inside. Tangent: Rs - rf.
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf.
        // Intersection is on the Left (-1).
        const topFillet = getFilletData(Rs, Rs - rf, r_hole + rf, -1);

        // 2. Bottom Fillet (Between Hole and Bottom S-Curve)
        // Bottom S-Curve: Center (0, -Rs). Material Outside (Scoop). Tangent: Rs + rf (External).
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf (External).
        // Intersection is on the Right (1).
        const botFillet = getFilletData(-Rs, Rs + rf, r_hole + rf, 1);

        // --- DRAW PATH ---

        // 1. Outer Arc (Right Semicircle)
        // From Bottom (0, -R) to Top (0, R)
        shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);

        // 2. Top S-Curve (Head)
        // From (0, R) to Top Fillet Start
        // Center (0, Rs), Radius Rs.
        // Start: PI/2. End: angleFromC1 of top fillet.
        shape.absarc(0, Rs, Rs, Math.PI / 2, topFillet.angleFromC1, false);

        // 3. Top Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC1 (Contact with S-curve).
        // End: angleFromC2 + PI (Contact with Hole).
        // CCW (false).
        shape.absarc(topFillet.fx, topFillet.fy, rf, topFillet.angleFromC1, topFillet.angleFromC2 + Math.PI, false);

        // 4. Center Cutout Arc (Hole)
        // From Top Fillet End to Bottom Fillet Start.
        // Center (0,0), Radius r_hole.
        // Start: topFillet.angleFromC2.
        // End: botFillet.angleFromC2.
        // CW (true).
        shape.absarc(0, 0, r_hole, topFillet.angleFromC2, botFillet.angleFromC2, true);

        // 5. Bottom Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC2 + PI (Contact with Hole).
        // End: angleFromC1 + PI (Contact with S-curve).
        // CCW (false).
        shape.absarc(botFillet.fx, botFillet.fy, rf, botFillet.angleFromC2 + Math.PI, botFillet.angleFromC1 + Math.PI, false);

        // 6. Bottom S-Curve (Tail Scoop)
        // From Bottom Fillet End to (0, -R).
        // Center (0, -Rs), Radius Rs.
        // Start: botFillet.angleFromC1.
        // End: -PI/2.
        // CW (true).
        shape.absarc(0, -Rs, Rs, botFillet.angleFromC1, -Math.PI / 2, true);

        // 7. The "Dot" (Hole in the Head)
        // Center: (0, Rs) -> Center of the Top S-Curve
        // Radius: Let's say Rs / 3.5 for a good proportion
        const dotRadius = Rs / 3.5;
        const dotPath = new THREE.Path();
        dotPath.absarc(0, Rs, dotRadius, 0, Math.PI * 2, true); // CW for hole
        shape.holes.push(dotPath);

        const geo = new THREE.ExtrudeGeometry(shape, {depth: shapeThickness, bevelEnabled: false});
        geo.translate(0, 0, -shapeThickness / 2);
        return new THREE.Mesh(geo, null);
    }

    // C. The Bearings
    function createBearingArc(radius, count) {
        const group = new THREE.Group();
        const bearingGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 16);
        bearingGeo.rotateX(Math.PI / 2);
        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;

        for (let i = 0; i < count; i++) {
            const t = i / (count - 1);
            const angle = startAngle + t * (endAngle - startAngle);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const dist = Math.sqrt(x * x + y * y);
            if (dist > centerHoleRadius + 0.3) {
                const bearing = new THREE.Mesh(bearingGeo, matSilver);
                bearing.position.set(x, y, 0);
                bearing.rotation.z = angle;
                if (i > 0 && i < count - 1) {
                    group.add(bearing);
                }
            }
        }
        return group;
    }

    // 5. BUILD SCENE

    // --- SYSTEM P (Vertical) ---
    const frameP = createGappedFrame(frameRadius);
    frameP.rotation.y = Math.PI / 2;
    scene.add(frameP);

    const rotorP = new THREE.Group();
    const shapeP = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeP.material = matYinWhite;
    rotorP.add(shapeP);
    rotorP.add(createBearingArc(frameRadius, 9));
    rotorP.rotation.y = Math.PI / 2;
    scene.add(rotorP);

    // --- SYSTEM O (Horizontal) ---
    const frameO = createGappedFrame(frameRadius);
    frameO.rotation.x = Math.PI / 2;
    frameO.rotation.z = Math.PI / 2;
    scene.add(frameO);

    const rotorO = new THREE.Group();
    const shapeO = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeO.material = matYangBlack;
    rotorO.add(shapeO);
    rotorO.add(createBearingArc(frameRadius, 9));

    rotorO.rotation.x = Math.PI / 2;
    rotorO.rotation.z = Math.PI / 2;
    scene.add(rotorO);

    // 6. ANIMATION
    let time = 0;
    let isPlaying = true;
    let isFlipped = false;
    let lagDegrees = 0;
    let lagRadians = 0;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            time += 0.015;
            rotorP.rotation.z = time;
            rotorO.rotation.z = (time + lagRadians) + Math.PI / 2;
        }
        renderer.render(scene, camera);
    }

    animate();

    // 7. UI
    const slider = document.getElementById('phaseSlider');
    const valLabel = document.getElementById('phaseVal');

    slider.addEventListener('input', (e) => {
        lagDegrees = parseInt(e.target.value);
        lagRadians = lagDegrees * (Math.PI / 180);
        valLabel.textContent = lagDegrees;

        if (!isPlaying) {
            rotorO.rotation.z = (rotorP.rotation.z + lagRadians) + Math.PI / 2;
            renderer.render(scene, camera);
        }
    });

    document.getElementById('toggleBtn').addEventListener('click', (e) => {
        isPlaying = !isPlaying;
        e.target.textContent = isPlaying ? "Pause Animation" : "Resume Animation";
    });

    document.getElementById('flipBtn').addEventListener('click', (e) => {
        isFlipped = !isFlipped;
        shapeO.scale.y = isFlipped ? -1 : 1;
        e.target.textContent = isFlipped ? "Un-Flip (Standard)" : "Flip (Mirror)";
        if (!isPlaying) renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>

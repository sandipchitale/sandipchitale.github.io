<!DOCTYPE html>
<html>
<head>
    <title>Encased Intersection Gimbal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #888;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }

        h2 {
            margin: 0;
            color: #ccc;
        }

        p {
            margin: 5px;
            font-size: 0.9em;
        }

        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 240px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            color: white;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }

        button:hover {
            background: #555;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .highlight {
            color: #00ddee;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="controls">
    <label for="phaseSlider">Lag: <span id="phaseVal" class="highlight">0</span> degrees</label>
    <input type="range" id="phaseSlider" min="0" max="180" value="0" step="1">

    <label style="margin-top:15px">Flip Black Shape:</label>
    <button id="flipBtn">Flip (Mirror)</button>

    <button id="toggleBtn" style="background: #2a662a; border-color:#484;">Pause Animation</button>

    <div style="margin-top: 20px; border-top: 1px solid #555; padding-top: 10px;">
        <label>3D Print Export:</label>
        <button id="exportFrameBtn">Export Frame (STL)</button>
        <button id="exportYinBtn">Export Yin Rotor (STL)</button>
        <button id="exportYangBtn">Export Yang Rotor (STL)</button>
    </div>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
    import {STLExporter} from 'three/addons/exporters/STLExporter.js';

    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. LIGHTING
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x00ddee, 1.0);
    backLight.position.set(-5, -5, -5);
    scene.add(backLight);

    // 3. MATERIALS & DIMENSIONS
    const frameRadius = 4.0;
    const splitGap = 0.12;
    const splitTubeRadius = 0.08;
    const outerClampRadius = 0.36;

    const shapeRadius = frameRadius - 0.35; // Reduced to 3.65 to prevent obscuration by square frame
    const shapeThickness = 0.15; // Slightly thicker for visibility
    const centerHoleRadius = 0.35; // Size of the central "ark" cutout

    // Gap Angle (How much material to remove at intersection)
    const intersectionGap = Math.PI / 36;

    const matWhite = new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.2});
    const matYinWhite = new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide});
    const matYangBlack = new THREE.MeshStandardMaterial({color: 0x111111, side: THREE.DoubleSide}); // Dark grey to be visible against bg
    const matSilver = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.9, roughness: 0.1});

    const matGlass = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff,
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.5, // Reduced from 0.95 for less translucency
        transparent: true,
        opacity: 0.5,      // Increased from 0.3 for more visibility
        side: THREE.DoubleSide,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });

    // 4. GEOMETRY FUNCTIONS

    // A. The "Gapped" Frame
    // A. The "Gapped" Frame (Square Profile with T-Slot via Lathe)
    function createGappedFrame(radius) {
        const group = new THREE.Group();

        // Define the profile for LatheGeometry (Square Cross-Section with T-Slot)
        // The Lathe revolves around the Y axis.
        // The profile is defined in the XY plane.

        // Dimensions for Square Profile
        const frameThickness = 0.5; // Total thickness (height)
        const frameWidth = 0.5;     // Total width (radial)
        const halfThick = frameThickness / 2;
        const halfWidth = frameWidth / 2;

        // Center of the tube profile is at x = radius (4.0)
        const cx = radius;

        // Groove Dimensions (T-Slot)
        // Mouth (Opening)
        const mouthWidth = 0.14;
        const hMouth = mouthWidth / 2;
        
        // Chamber (Internal Cavity)
        const chamberWidth = 0.24;
        const hChamber = chamberWidth / 2;
        const chamberDepth = 0.15; // Depth from inner face to back wall
        const chamberStartDepth = 0.05; // Depth from inner face where chamber starts (lip thickness)

        // Inner Face X: cx - halfWidth
        const xInner = cx - halfWidth;
        // Outer Face X: cx + halfWidth
        const xOuter = cx + halfWidth;
        
        // T-Slot X Coordinates
        const xChamberStart = xInner + chamberStartDepth;
        const xChamberBack = xInner + chamberDepth;

        const points = [];

        // 1. Top-Inner Lip (Start at top of groove mouth)
        points.push(new THREE.Vector2(xInner, hMouth));

        // 2. Step IN to Chamber Front Top
        points.push(new THREE.Vector2(xChamberStart, hMouth));

        // 3. Step UP to Chamber Top
        points.push(new THREE.Vector2(xChamberStart, hChamber));

        // 4. Step IN to Chamber Back Top
        points.push(new THREE.Vector2(xChamberBack, hChamber));

        // 5. Step DOWN to Chamber Back Bottom
        points.push(new THREE.Vector2(xChamberBack, -hChamber));

        // 6. Step OUT to Chamber Front Bottom
        points.push(new THREE.Vector2(xChamberStart, -hChamber));

        // 7. Step DOWN to Mouth Bottom
        points.push(new THREE.Vector2(xChamberStart, -hMouth));

        // 8. Step OUT to Bottom-Inner Lip
        points.push(new THREE.Vector2(xInner, -hMouth));

        // 9. Go DOWN to Bottom-Inner Corner
        points.push(new THREE.Vector2(xInner, -halfThick));

        // 10. Go RIGHT to Bottom-Outer Corner
        points.push(new THREE.Vector2(xOuter, -halfThick));

        // 11. Go UP to Top-Outer Corner
        points.push(new THREE.Vector2(xOuter, halfThick));

        // 12. Go LEFT to Top-Inner Corner
        points.push(new THREE.Vector2(xInner, halfThick));

        // 13. Close loop (Go DOWN to Top-Inner Lip)
        points.push(new THREE.Vector2(xInner, hMouth));

        // Create LatheGeometry
        const geometry = new THREE.LatheGeometry(points, 128); // 128 segments for smooth torus

        // Lathe creates a torus with axis Y.
        // Standard TorusGeometry has axis Z.
        // We need to rotate X by 90 deg to match Torus orientation (Hole along Z).
        geometry.rotateX(Math.PI / 2);

        const mesh = new THREE.Mesh(geometry, matGlass);
        group.add(mesh);

        return group;
    }

    // B. The Safe Yin/Yang Shape (Calculated Contour)
    function createTeardropShape(R, r_hole) {
        const shape = new THREE.Shape();
        const Rs = R / 2; // Radius of small circles
        const rf = 0.15; // Fillet radius

        // Helper to find fillet center and angles
        // Solves intersection of two circles centered at (0, y1) and (0, 0) with radii d1 and d2
        // intersectionSign: -1 for Left (Top), 1 for Right (Bottom)
        function getFilletData(y1, d1, d2, intersectionSign) {
            // Solve for fillet center (fx, fy)
            // x^2 + (y - y1)^2 = d1^2
            // x^2 + y^2 = d2^2
            
            const fy = (y1 * y1 - d1 * d1 + d2 * d2) / (2 * y1);
            const fx = intersectionSign * Math.sqrt(d2 * d2 - fy * fy);
            
            // Angles from centers to fillet center
            const angleFromC1 = Math.atan2(fy - y1, fx);
            const angleFromC2 = Math.atan2(fy, fx);
            
            return { fx, fy, angleFromC1, angleFromC2 };
        }

        // 1. Top Fillet (Between Top S-Curve and Hole)
        // Top S-Curve: Center (0, Rs). Material Inside. Tangent: Rs - rf.
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf.
        // Intersection is on the Left (-1).
        const topFillet = getFilletData(Rs, Rs - rf, r_hole + rf, -1);

        // 2. Bottom Fillet (Between Hole and Bottom S-Curve)
        // Bottom S-Curve: Center (0, -Rs). Material Outside (Scoop). Tangent: Rs + rf (External).
        // Hole: Center (0, 0). Material Outside. Tangent: r_hole + rf (External).
        // Intersection is on the Right (1).
        const botFillet = getFilletData(-Rs, Rs + rf, r_hole + rf, 1);

        // --- DRAW PATH ---

        // 1. Outer Arc (Right Semicircle)
        // From Bottom (0, -R) to Top (0, R)
        shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);

        // 2. Top S-Curve (Head)
        // From (0, R) to Top Fillet Start
        // Center (0, Rs), Radius Rs.
        // Start: PI/2. End: angleFromC1 of top fillet.
        shape.absarc(0, Rs, Rs, Math.PI / 2, topFillet.angleFromC1, false);

        // 3. Top Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC1 (Contact with S-curve).
        // End: angleFromC2 + PI (Contact with Hole).
        // CCW (false).
        shape.absarc(topFillet.fx, topFillet.fy, rf, topFillet.angleFromC1, topFillet.angleFromC2 + Math.PI, false);

        // 4. Center Cutout Arc (Hole)
        // From Top Fillet End to Bottom Fillet Start.
        // Center (0,0), Radius r_hole.
        // Start: topFillet.angleFromC2.
        // End: botFillet.angleFromC2.
        // CW (true).
        shape.absarc(0, 0, r_hole, topFillet.angleFromC2, botFillet.angleFromC2, true);

        // 5. Bottom Fillet
        // Center (fx, fy), Radius rf.
        // Start: angleFromC2 + PI (Contact with Hole).
        // End: angleFromC1 + PI (Contact with S-curve).
        // CCW (false).
        shape.absarc(botFillet.fx, botFillet.fy, rf, botFillet.angleFromC2 + Math.PI, botFillet.angleFromC1 + Math.PI, false);

        // 6. Bottom S-Curve (Tail Scoop)
        // From Bottom Fillet End to (0, -R).
        // Center (0, -Rs), Radius Rs.
        // Start: botFillet.angleFromC1.
        // End: -PI/2.
        // CW (true).
        shape.absarc(0, -Rs, Rs, botFillet.angleFromC1, -Math.PI / 2, true);

        // 7. The "Dot" (Hole in the Head)
        // Center: (0, Rs) -> Center of the Top S-Curve
        // Radius: Let's say Rs / 3.5 for a good proportion
        const dotRadius = Rs / 3.5;
        const dotPath = new THREE.Path();
        dotPath.absarc(0, Rs, dotRadius, 0, Math.PI * 2, true); // CW for hole
        shape.holes.push(dotPath);

        const geo = new THREE.ExtrudeGeometry(shape, {depth: shapeThickness, bevelEnabled: false});
        geo.translate(0, 0, -shapeThickness / 2);
        return new THREE.Mesh(geo, null);
    }

    // C. The Bearings (Captive Studs)
    function createBearingArc(radius, count, material) {
        const group = new THREE.Group();
        
        // Bearing Dimensions
        const headRadius = 0.10; // Fits in 0.24 chamber
        const headHeight = 0.10;
        const neckRadius = 0.06; // Fits in 0.14 mouth
        
        // Distance from Frame Center (radius=4.0) to Rotor Edge (3.65)
        // We need to bridge this gap.
        // The bearing center is at 'radius'.
        // The "Head" is centered at 'radius'.
        // The "Stem" needs to go from 'radius' inwards to 'shapeRadius' (3.65).
        // Total stem length = radius - shapeRadius = 0.35.
        // Actually, let's make it slightly longer to penetrate the rotor for solid connection.
        const stemLength = (radius - shapeRadius) + 0.05; 

        const headGeo = new THREE.CylinderGeometry(headRadius, headRadius, headHeight, 16);
        headGeo.rotateX(Math.PI / 2); // Align with radial direction (Z in local bearing space)
        
        const stemGeo = new THREE.CylinderGeometry(neckRadius, neckRadius, stemLength, 16);
        stemGeo.rotateX(Math.PI / 2);
        // Shift stem so it starts at center and goes inwards (negative Z in local space? No, we rotate the whole thing)
        // Let's build it in local coordinates where Z is the radial axis.
        // Head is at Z=0.
        // Stem extends from Z=0 to Z=-stemLength.
        stemGeo.translate(0, 0, -stemLength / 2);

        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;

        for (let i = 0; i < count; i++) {
            const t = i / (count - 1);
            const angle = startAngle + t * (endAngle - startAngle);
            
            // Position on the circle
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const dist = Math.sqrt(x * x + y * y);
            if (dist > centerHoleRadius + 0.3) {
                const bearingGroup = new THREE.Group();
                
                const head = new THREE.Mesh(headGeo, material);
                const stem = new THREE.Mesh(stemGeo, material);
                
                bearingGroup.add(head);
                bearingGroup.add(stem);
                
                // Position the group on the ring
                bearingGroup.position.set(x, y, 0);
                
                // Rotate so the stem points INWARDS (towards center)
                // The stem geometry extends along negative Z.
                // If we rotate Z by 'angle', the local X/Y axes rotate.
                // We need the local Z axis to point OUTWARDS (so negative Z points INWARDS).
                // Standard rotation.z = angle aligns local X with tangent? No.
                // Let's check standard orientation.
                bearingGroup.rotation.z = angle;
                // At angle=0 (Right), x=R, y=0. Local Z points out of screen? No.
                // We need to orient the cylinder axis (which is Z after rotateX(PI/2)?)
                // Wait, Cylinder default is Y axis. rotateX(PI/2) makes it Z axis.
                // So Head and Stem are along Z axis.
                // We want this Z axis to align with the radial vector (cos(angle), sin(angle)).
                // At angle=0, radial vector is (1,0,0).
                // We need to rotate the group so its Z axis points to (1,0,0).
                // By default Z is (0,0,1).
                // Rotate Y by PI/2 -> Z becomes X.
                bearingGroup.rotateY(Math.PI / 2); 
                // Now Z axis is along World X.
                // Then rotate around World Z by 'angle'.
                // But we are inside a group that might be rotated? No, this is local to the arc.
                
                // Simpler approach: LookAt.
                // Position is at (x,y,0).
                // Look at (2*x, 2*y, 0) -> Points Z axis outwards.
                bearingGroup.lookAt(2*x, 2*y, 0);

                if (i > 0 && i < count - 1) {
                    group.add(bearingGroup);
                }
            }
        }
        return group;
    }

    // 5. BUILD SCENE

    // --- SYSTEM P (Vertical) ---
    const frameP = createGappedFrame(frameRadius);
    frameP.rotation.y = Math.PI / 2;
    scene.add(frameP);

    const rotorP = new THREE.Group();
    const shapeP = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeP.material = matYinWhite;
    rotorP.add(shapeP);
    rotorP.add(createBearingArc(frameRadius, 9, matYinWhite));
    rotorP.rotation.y = Math.PI / 2;
    scene.add(rotorP);

    // --- SYSTEM O (Horizontal) ---
    const frameO = createGappedFrame(frameRadius);
    frameO.rotation.x = Math.PI / 2;
    frameO.rotation.z = Math.PI / 2;
    scene.add(frameO);

    const rotorO = new THREE.Group();
    const shapeO = createTeardropShape(shapeRadius, centerHoleRadius);
    shapeO.material = matYangBlack;
    rotorO.add(shapeO);
    rotorO.add(createBearingArc(frameRadius, 9, matYangBlack));

    rotorO.rotation.x = Math.PI / 2;
    rotorO.rotation.z = Math.PI / 2;
    scene.add(rotorO);

    // 6. ANIMATION
    let time = 0;
    let isPlaying = true;
    let isFlipped = false;
    let lagDegrees = 0;
    let lagRadians = 0;

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            time += 0.015;
            rotorP.rotation.z = time;
            rotorO.rotation.z = (time + lagRadians) + Math.PI / 2;
        }
        renderer.render(scene, camera);
    }

    animate();

    // 7. UI
    const slider = document.getElementById('phaseSlider');
    const valLabel = document.getElementById('phaseVal');

    slider.addEventListener('input', (e) => {
        lagDegrees = parseInt(e.target.value);
        lagRadians = lagDegrees * (Math.PI / 180);
        valLabel.textContent = lagDegrees;

        if (!isPlaying) {
            rotorO.rotation.z = (rotorP.rotation.z + lagRadians) + Math.PI / 2;
            renderer.render(scene, camera);
        }
    });

    document.getElementById('toggleBtn').addEventListener('click', (e) => {
        isPlaying = !isPlaying;
        e.target.textContent = isPlaying ? "Pause Animation" : "Resume Animation";
    });

    document.getElementById('flipBtn').addEventListener('click', (e) => {
        isFlipped = !isFlipped;
        shapeO.scale.y = isFlipped ? -1 : 1;
        e.target.textContent = isFlipped ? "Un-Flip (Standard)" : "Flip (Mirror)";
        if (!isPlaying) renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // 8. EXPORT LOGIC
    const exporter = new STLExporter();

    function exportToSTL(object, filename) {
        const result = exporter.parse(object, { binary: true });
        const blob = new Blob([result], { type: 'application/octet-stream' });
        const link = document.createElement('a');
        link.style.display = 'none';
        document.body.appendChild(link);
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
        document.body.removeChild(link);
    }

    document.getElementById('exportFrameBtn').addEventListener('click', () => {
        // Create a clean instance for export (no rotation)
        const exportFrame = createGappedFrame(frameRadius);
        exportToSTL(exportFrame, 'gimbal_frame.stl');
    });

    document.getElementById('exportYinBtn').addEventListener('click', () => {
        // Recreate Yin Rotor in neutral position
        const exportRotor = new THREE.Group();
        const shape = createTeardropShape(shapeRadius, centerHoleRadius);
        shape.material = matYinWhite; // Material doesn't matter for STL but keeps logic consistent
        exportRotor.add(shape);
        exportRotor.add(createBearingArc(frameRadius, 9, matYinWhite));
        exportToSTL(exportRotor, 'gimbal_yin_rotor.stl');
    });

    document.getElementById('exportYangBtn').addEventListener('click', () => {
        // Recreate Yang Rotor in neutral position
        const exportRotor = new THREE.Group();
        const shape = createTeardropShape(shapeRadius, centerHoleRadius);
        shape.material = matYangBlack;
        exportRotor.add(shape);
        exportRotor.add(createBearingArc(frameRadius, 9, matYangBlack));
        exportToSTL(exportRotor, 'gimbal_yang_rotor.stl');
    });
</script>
</body>
</html>

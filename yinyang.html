<><!DOCTYPE html>
<html>
<head>
    <title>Encased Intersection Gimbal</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            font-family: sans-serif;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            z-index: 1;
            text-shadow: 1px 1px 2px black;
        }

        #controls {
            position: absolute;
            top: 60px;
            right: 20px;
            width: 240px;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            color: white;
            border-radius: 8px;
            z-index: 2;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        button {
            margin-top: 15px;
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: #444;
            color: white;
            border: 1px solid #666;
            border-radius: 4px;
        }

        button:hover {
            background: #555;
        }

        label {
            display: block;
            margin-bottom: 10px;
            font-size: 0.9em;
            font-weight: bold;
            color: #ccc;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .highlight {
            color: #00ddee;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="info">
    <h2>Encased Intersection Gimbal</h2>
    <p>Split internal rails â€¢ Continuous outer glass shell</p>
</div>

<div id="controls">
    <label for="phaseSlider">Lag: <span id="phaseVal" class="highlight">90</span> degrees</label>
    <input type="range" id="phaseSlider" min="0" max="180" value="0" step="1">

    <label style="margin-top:15px">Flip Orange Shape:</label>
    <button id="flipBtn">Flip (Mirror)</button>

    <button id="toggleBtn" style="background: #2a662a; border-color:#484;">Pause Animation</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import {OrbitControls} from 'three/addons/controls/OrbitControls.js';

    // 1. SCENE SETUP
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // 2. LIGHTING
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 5);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x00ddee, 0.8);
    backLight.position.set(-5, -5, -5);
    scene.add(backLight);

    // 3. MATERIALS & DIMENSIONS
    const frameRadius = 4.0;
    const splitGap = 0.12;
    const splitTubeRadius = 0.08;
    const outerClampRadius = 0.36; // DOUBLED thickness: was 0.18, now 0.36

    const shapeRadius = frameRadius - 0.1;
    const shapeThickness = 0.06;

    // Gap Angle (How much material to remove at intersection)
    const intersectionGap = Math.PI / 8;

    const matWhite = new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.2});
    const matPurple = new THREE.MeshStandardMaterial({color: 0x9b30ff, side: THREE.DoubleSide});
    const matOrange = new THREE.MeshStandardMaterial({color: 0xffaa00, side: THREE.DoubleSide});
    const matSilver = new THREE.MeshStandardMaterial({color: 0xffffff, metalness: 0.9, roughness: 0.1});

    const matGlass = new THREE.MeshPhysicalMaterial({
        color: 0xaaccff, // Slight blue tint
        metalness: 0.1,
        roughness: 0.05,
        transmission: 0.95,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide,
        clearcoat: 1.0,
        clearcoatRoughness: 0.1
    });

    // 4. GEOMETRY FUNCTIONS

    // A. The "Gapped" Frame with Continuous Shell
    function createGappedFrame(radius) {
        const group = new THREE.Group();

        // --- 1. The Internal Split Rails (White) ---
        const arcLength = Math.PI - intersectionGap;
        const start1 = intersectionGap / 2;
        const start2 = Math.PI + intersectionGap / 2;

        function buildRail(zOffset) {
            const railGroup = new THREE.Group();

            // Arc 1
            const geo1 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo1.rotateZ(start1);
            const mesh1 = new THREE.Mesh(geo1, matWhite);
            mesh1.position.z = zOffset;
            railGroup.add(mesh1);

            // Arc 2
            const geo2 = new THREE.TorusGeometry(radius, splitTubeRadius, 16, 64, arcLength);
            geo2.rotateZ(start2);
            const mesh2 = new THREE.Mesh(geo2, matWhite);
            mesh2.position.z = zOffset;
            railGroup.add(mesh2);

            return railGroup;
        }

        group.add(buildRail(splitGap / 2 + splitTubeRadius / 2));      // Top Lip
        group.add(buildRail(-(splitGap / 2 + splitTubeRadius / 2)));   // Bottom Lip

        // --- 2. The Outer Wrapper (Glass) ---
        const glassGeo = new THREE.TorusGeometry(radius, outerClampRadius, 24, 100, Math.PI * 2);
        const glassMesh = new THREE.Mesh(glassGeo, matGlass);
        group.add(glassMesh);

        return group;
    }

    // B. The Yin/Yang Shape
    function createTeardropShape(radius) {
        const shape = new THREE.Shape();
        shape.absarc(0, 0, radius, -Math.PI / 2, Math.PI / 2, false);
        shape.absarc(0, radius / 2, radius / 2, Math.PI / 2, 3 * Math.PI / 2, false);
        shape.absarc(0, -radius / 2, radius / 2, Math.PI / 2, 3 * Math.PI / 2, true);

        const geo = new THREE.ExtrudeGeometry(shape, {depth: shapeThickness, bevelEnabled: false});
        geo.translate(0, 0, -shapeThickness / 2);
        return new THREE.Mesh(geo, null);
    }

    // C. The Bearings
    function createBearingArc(radius, count) {
        const group = new THREE.Group();
        const bearingGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.08, 16);
        bearingGeo.rotateX(Math.PI / 2);
        const startAngle = -Math.PI / 2;
        const endAngle = Math.PI / 2;

        for (let i = 0; i < count; i++) {
            const t = i / (count - 1);
            const angle = startAngle + t * (endAngle - startAngle);
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);

            const bearing = new THREE.Mesh(bearingGeo, matSilver);
            bearing.position.set(x, y, 0);
            bearing.rotation.z = angle;
            group.add(bearing);
        }
        return group;
    }

    // 5. BUILD SCENE

    // --- SYSTEM P (Vertical) ---
    const frameP = createGappedFrame(frameRadius);
    frameP.rotation.y = Math.PI / 2;
    scene.add(frameP);

    const rotorP = new THREE.Group();
    const shapeP = createTeardropShape(shapeRadius);
    shapeP.material = matPurple;
    rotorP.add(shapeP);
    rotorP.add(createBearingArc(frameRadius, 9));
    rotorP.rotation.y = Math.PI / 2;
    scene.add(rotorP);


    // --- SYSTEM O (Horizontal) ---
    const frameO = createGappedFrame(frameRadius);
    frameO.rotation.x = Math.PI / 2;
    frameO.rotation.z = Math.PI / 2;
    scene.add(frameO);

    const rotorO = new THREE.Group();
    const shapeO = createTeardropShape(shapeRadius);
    shapeO.material = matOrange;
    rotorO.add(shapeO);
    rotorO.add(createBearingArc(frameRadius, 9));

    rotorO.rotation.x = Math.PI / 2;
    rotorO.rotation.z = Math.PI / 2;
    scene.add(rotorO);


    // 6. ANIMATION
    let time = 0;
    let isPlaying = true;
    let isFlipped = false;
    let lagDegrees = 0;
    let lagRadians = lagDegrees * (Math.PI / 180);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        if (isPlaying) {
            time += 0.015;

            // ROTATION LOGIC
            rotorP.rotation.z = time;

            // Frame O offset logic
            rotorO.rotation.z = (time + lagRadians) + Math.PI / 2;
        }
        renderer.render(scene, camera);
    }

    animate();

    // 7. UI
    const slider = document.getElementById('phaseSlider');
    const valLabel = document.getElementById('phaseVal');

    slider.addEventListener('input', (e) => {
        lagDegrees = parseInt(e.target.value);
        lagRadians = lagDegrees * (Math.PI / 180);
        valLabel.textContent = lagDegrees;

        if (!isPlaying) {
            rotorO.rotation.z = (rotorP.rotation.z + lagRadians) + Math.PI / 2;
            renderer.render(scene, camera);
        }
    });

    document.getElementById('toggleBtn').addEventListener('click', (e) => {
        isPlaying = !isPlaying;
        e.target.textContent = isPlaying ? "Pause Animation" : "Resume Animation";
    });

    document.getElementById('flipBtn').addEventListener('click', (e) => {
        isFlipped = !isFlipped;
        shapeO.scale.y = isFlipped ? -1 : 1;
        e.target.textContent = isFlipped ? "Un-Flip (Standard)" : "Flip (Mirror)";
        if (!isPlaying) renderer.render(scene, camera);
    });

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
</>

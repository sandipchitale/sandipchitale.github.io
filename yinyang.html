<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encased Intersection Gimbal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #ccc;
            pointer-events: none;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #info h1 {
            font-size: 2em;
            font-weight: 300;
            margin-bottom: 8px;
            color: #fff;
        }

        #info p {
            font-size: 0.9em;
            color: #aaa;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            z-index: 10;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #controls.collapsed {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }

        #controls-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            z-index: 11;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #controls-toggle:hover {
            background: rgba(0, 0, 0, 0.85);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .control-section h3 {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 12px;
            font-weight: 600;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #ccc;
        }

        .value-display {
            color: #00ddff;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ddff;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ddff;
            cursor: pointer;
            border: none;
            transition: transform 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
        }

        button.primary:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        button.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            border-color: transparent;
        }

        button.success:hover {
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <button id="controls-toggle" title="Toggle Controls">☰</button>
    
    <div id="controls" class="collapsed">
        <div class="control-section">
            <h3>Animation</h3>
            <button id="toggleAnimation" class="primary">Pause Animation</button>
        </div>

        <div class="control-section">
            <h3>Visibility</h3>
            <button id="toggleYin" class="success">Hide Yin Assembly</button>
            <button id="toggleYang" class="success">Hide Yang Assembly</button>
            <button id="toggleFrame" class="success">Hide Frame</button>
        </div>

        <div class="control-section">
            <h3>3D Print Export</h3>
            <button id="exportFrame">Export Frame (STL)</button>
            <button id="exportYin">Export Yin Rotor (STL)</button>
            <button id="exportYang">Export Yang Rotor (STL)</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';

        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        
        const CONFIG = {
            // Dimensions
            frameRadius: 4.0,
            shapeRadius: 3.65,
            shapeThickness: 0.15,
            centerHoleRadius: 0.35,
            
            // Frame profile - T-slot dimensions
            frameThickness: 0.4,       // Reduced from 0.8 - much thinner walls
            frameWidth: 0.5,           // Reduced from 0.8 - thinner profile
            tSlotMouthWidth: 0.3,      // Mouth opening (narrow part)
            tSlotChamberWidth: 0.5,    // Chamber width (wide part)
            tSlotChamberDepth: 0.3,    // How deep the chamber goes
            tSlotLipDepth: 0.08,       // Lip thickness before chamber
            
            // Bearing dimensions
            bearingHeadRadius: 0.10,
            bearingHeadHeight: 0.10,
            bearingNeckRadius: 0.06,
            bearingCount: 9,
            
            // Animation
            rotationSpeed: 0.015,
            
            // Geometry
            latheSegments: 128,
            cylinderSegments: 16,
            filletRadius: 0.15
        };

        // ============================================================================
        // SCENE SETUP
        // ============================================================================
        
        class GimbalScene {
            constructor() {
                this.initScene();
                this.initLights();
                this.initMaterials();
                this.buildGimbal();
                this.initControls();
                this.initAnimation();
                this.initExporter();
                this.setupEventListeners();
                this.animate();
            }

            initScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);

                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(12, 10, 12);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Orbit controls
                this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
                this.orbitControls.enableDamping = true;
                this.orbitControls.dampingFactor = 0.05;
            }

            initLights() {
                // Ambient light - neutral white
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Main directional light - neutral white
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(5, 10, 5);
                this.scene.add(mainLight);

                // Fill light from opposite side - neutral white
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
                fillLight.position.set(-5, -3, -5);
                this.scene.add(fillLight);
            }

            initMaterials() {
                this.materials = {
                    glass: new THREE.MeshPhysicalMaterial({
                        color: 0xffffff,
                        metalness: 0.0,
                        roughness: 0.05,
                        transmission: 0.95,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.DoubleSide,
                        clearcoat: 1.0,
                        clearcoatRoughness: 0.05,
                        ior: 1.5
                    }),
                    yinWhite: new THREE.MeshStandardMaterial({
                        color: 0xf0f0f0,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    }),
                    yangBlack: new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    }),
                    yinRail: new THREE.MeshStandardMaterial({
                        color: 0xf0f0f0,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    }),
                    yangRail: new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    })
                };
            }

            // ========================================================================
            // GEOMETRY CREATION
            // ========================================================================

            createFrameGeometry() {
                const { frameRadius, frameThickness, frameWidth, 
                        tSlotMouthWidth, tSlotChamberWidth, 
                        tSlotChamberDepth, tSlotLipDepth, latheSegments } = CONFIG;

                const halfThick = frameThickness / 2;
                const halfWidth = frameWidth / 2;
                const cx = frameRadius;

                const hMouth = tSlotMouthWidth / 2;
                const hChamber = tSlotChamberWidth / 2;

                const xInner = cx - halfWidth;
                const xOuter = cx + halfWidth;
                const xChamberStart = xInner + tSlotLipDepth;
                const xChamberBack = xInner + tSlotChamberDepth;

                // Build T-slot profile
                const points = [
                    new THREE.Vector2(xInner, hMouth),
                    new THREE.Vector2(xChamberStart, hMouth),
                    new THREE.Vector2(xChamberStart, hChamber),
                    new THREE.Vector2(xChamberBack, hChamber),
                    new THREE.Vector2(xChamberBack, -hChamber),
                    new THREE.Vector2(xChamberStart, -hChamber),
                    new THREE.Vector2(xChamberStart, -hMouth),
                    new THREE.Vector2(xInner, -hMouth),
                    new THREE.Vector2(xInner, -halfThick),
                    new THREE.Vector2(xOuter, -halfThick),
                    new THREE.Vector2(xOuter, halfThick),
                    new THREE.Vector2(xInner, halfThick),
                    new THREE.Vector2(xInner, hMouth)
                ];

                const geometry = new THREE.LatheGeometry(points, latheSegments);
                geometry.rotateX(Math.PI / 2);

                return geometry;
            }

            createTeardropShape() {
                const { shapeRadius, centerHoleRadius, shapeThickness, filletRadius } = CONFIG;
                
                const R = shapeRadius;
                const r_hole = centerHoleRadius;
                const Rs = R / 2;
                const rf = filletRadius;

                const shape = new THREE.Shape();

                // Helper function for fillet calculations
                const getFilletData = (y1, d1, d2, intersectionSign) => {
                    const fy = (y1 * y1 - d1 * d1 + d2 * d2) / (2 * y1);
                    const fx = intersectionSign * Math.sqrt(d2 * d2 - fy * fy);
                    const angleFromC1 = Math.atan2(fy - y1, fx);
                    const angleFromC2 = Math.atan2(fy, fx);
                    return { fx, fy, angleFromC1, angleFromC2 };
                };

                // Calculate fillets
                const topFillet = getFilletData(Rs, Rs - rf, r_hole + rf, -1);
                const botFillet = getFilletData(-Rs, Rs + rf, r_hole + rf, 1);

                // Build the teardrop path
                shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);
                shape.absarc(0, Rs, Rs, Math.PI / 2, topFillet.angleFromC1, false);
                shape.absarc(topFillet.fx, topFillet.fy, rf, topFillet.angleFromC1, topFillet.angleFromC2 + Math.PI, false);
                shape.absarc(0, 0, r_hole, topFillet.angleFromC2, botFillet.angleFromC2, true);
                shape.absarc(botFillet.fx, botFillet.fy, rf, botFillet.angleFromC2 + Math.PI, botFillet.angleFromC1 + Math.PI, false);
                shape.absarc(0, -Rs, Rs, botFillet.angleFromC1, -Math.PI / 2, true);

                // Add the "dot" hole
                const dotRadius = Rs / 3.5;
                const dotPath = new THREE.Path();
                dotPath.absarc(0, Rs, dotRadius, 0, Math.PI * 2, true);
                shape.holes.push(dotPath);

                // Extrude the shape
                const geometry = new THREE.ExtrudeGeometry(shape, {
                    depth: shapeThickness,
                    bevelEnabled: false
                });
                geometry.translate(0, 0, -shapeThickness / 2);

                return geometry;
            }

            createBearingArc(material) {
                const { frameRadius, shapeRadius, tSlotMouthWidth, tSlotChamberWidth, shapeThickness } = CONFIG;

                // T-shaped rail dimensions (matches the T-slot in the frame)
                // The rail fits INTO the slot, so dimensions are slightly smaller for clearance
                const clearance = 0.02; // Small gap for sliding fit
                
                // Neck (fits through the mouth opening) - THIN, matches shape thickness
                const neckWidth = tSlotMouthWidth - clearance;
                const neckDepth = 0.12; // Depth of the neck portion
                
                // Head (fits in the chamber, prevents pull-out) - THICK AND WIDE
                const headWidth = tSlotChamberWidth - clearance; // Almost fills the chamber
                const headDepth = 0.15; // Thicker head for prominence
                
                // Stem (extends from slot to rotor) - THIN, matches shape thickness
                const stemWidth = shapeThickness; // Same as yin/yang shape thickness (0.15)
                const totalRailDepth = (frameRadius - shapeRadius) + 0.05;
                const stemDepth = totalRailDepth - neckDepth - headDepth;
                
                // Height (perpendicular to radial direction)
                // Only the HEAD is tall, neck and stem match shape thickness
                const headHeight = 0.25;      // Tall head
                const neckHeight = shapeThickness;  // Thin neck (0.15)
                const stemHeight = shapeThickness;  // Thin stem (0.15)

                // Shortened arc to prevent clashing at intersections
                const startAngle = -Math.PI / 2 + Math.PI / 18;  // -80° instead of -90°
                const endAngle = Math.PI / 2 - Math.PI / 18;      // +80° instead of +90°
                const segments = 64;

                const geometry = new THREE.BufferGeometry();
                const vertices = [];
                const indices = [];

                // Create vertices for the T-shaped rail
                // For each segment, we create vertices for the T-profile at different radial depths
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const angle = startAngle + t * (endAngle - startAngle);
                    
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Tangent direction (perpendicular to radial)
                    const tangentX = -sin;
                    const tangentY = cos;
                    
                    // Define radial positions (from outer to inner)
                    const r0 = frameRadius; // Outer edge (at frame)
                    const r1 = frameRadius - headDepth; // End of head
                    const r2 = frameRadius - headDepth - neckDepth; // End of neck
                    const r3 = frameRadius - totalRailDepth; // Inner edge (at rotor)
                    
                    // For each radial position, calculate the width at that point
                    // Head section (r0 to r1): wide
                    const hw0 = headWidth / 2;
                    const hw1 = headWidth / 2;
                    const hh0 = headHeight / 2;  // Tall head
                    const hh1 = headHeight / 2;
                    
                    // Neck section (r1 to r2): narrow
                    const hw2 = neckWidth / 2;
                    const hh2 = neckHeight / 2;  // Thin neck
                    
                    // Stem section (r2 to r3): thin like shape
                    const hw3 = stemWidth / 2;
                    const hh3 = stemHeight / 2;  // Thin stem
                    
                    // Calculate positions for each section
                    // Section 0: Head outer edge (at frame)
                    const x0 = r0 * cos;
                    const y0 = r0 * sin;
                    
                    // Section 1: Head inner edge
                    const x1 = r1 * cos;
                    const y1 = r1 * sin;
                    
                    // Section 2: Neck inner edge
                    const x2 = r2 * cos;
                    const y2 = r2 * sin;
                    
                    // Section 3: Stem inner edge (at rotor)
                    const x3 = r3 * cos;
                    const y3 = r3 * sin;
                    
                    // Create vertices for T-profile
                    // Each section has 4 vertices (top-left, top-right, bottom-right, bottom-left)
                    
                    // Head outer (4 vertices) - TALL
                    vertices.push(
                        x0 - tangentX * hw0, y0 - tangentY * hw0, hh0,  // Top-left
                        x0 + tangentX * hw0, y0 + tangentY * hw0, hh0,  // Top-right
                        x0 + tangentX * hw0, y0 + tangentY * hw0, -hh0, // Bottom-right
                        x0 - tangentX * hw0, y0 - tangentY * hw0, -hh0  // Bottom-left
                    );
                    
                    // Head inner (4 vertices) - TALL
                    vertices.push(
                        x1 - tangentX * hw1, y1 - tangentY * hw1, hh1,
                        x1 + tangentX * hw1, y1 + tangentY * hw1, hh1,
                        x1 + tangentX * hw1, y1 + tangentY * hw1, -hh1,
                        x1 - tangentX * hw1, y1 - tangentY * hw1, -hh1
                    );
                    
                    // Neck inner (4 vertices) - THIN
                    vertices.push(
                        x2 - tangentX * hw2, y2 - tangentY * hw2, hh2,
                        x2 + tangentX * hw2, y2 + tangentY * hw2, hh2,
                        x2 + tangentX * hw2, y2 + tangentY * hw2, -hh2,
                        x2 - tangentX * hw2, y2 - tangentY * hw2, -hh2
                    );
                    
                    // Stem inner (4 vertices) - THIN
                    vertices.push(
                        x3 - tangentX * hw3, y3 - tangentY * hw3, hh3,
                        x3 + tangentX * hw3, y3 + tangentY * hw3, hh3,
                        x3 + tangentX * hw3, y3 + tangentY * hw3, -hh3,
                        x3 - tangentX * hw3, y3 - tangentY * hw3, -hh3
                    );
                }

                // Create faces connecting the segments
                const vertsPerSegment = 16; // 4 sections × 4 vertices each
                
                for (let i = 0; i < segments; i++) {
                    const base = i * vertsPerSegment;
                    const next = (i + 1) * vertsPerSegment;
                    
                    // Helper function to create a quad face
                    const quad = (a, b, c, d) => {
                        indices.push(a, b, c);
                        indices.push(a, c, d);
                    };
                    
                    // Head section (vertices 0-7)
                    quad(base + 0, next + 0, next + 1, base + 1); // Top
                    quad(base + 1, next + 1, next + 2, base + 2); // Right
                    quad(base + 2, next + 2, next + 3, base + 3); // Bottom
                    quad(base + 3, next + 3, next + 0, base + 0); // Left
                    
                    quad(base + 4, base + 5, next + 5, next + 4); // Top (inner)
                    quad(base + 5, base + 6, next + 6, next + 5); // Right (inner)
                    quad(base + 6, base + 7, next + 7, next + 6); // Bottom (inner)
                    quad(base + 7, base + 4, next + 4, next + 7); // Left (inner)
                    
                    // Radial faces connecting outer to inner of head
                    quad(base + 0, base + 4, next + 4, next + 0); // Top radial
                    quad(base + 1, base + 5, next + 5, next + 1); // Right radial
                    quad(base + 2, base + 6, next + 6, next + 2); // Bottom radial
                    quad(base + 3, base + 7, next + 7, next + 3); // Left radial
                    
                    // Transition from head to neck (fill the step)
                    // Top transition
                    quad(base + 4, next + 4, next + 8, base + 8);
                    // Right transition
                    quad(base + 5, next + 5, next + 9, base + 9);
                    // Bottom transition
                    quad(base + 6, next + 6, next + 10, base + 10);
                    // Left transition
                    quad(base + 7, next + 7, next + 11, base + 11);
                    
                    // Neck section (vertices 8-11)
                    quad(base + 8, next + 8, next + 9, base + 9); // Top
                    quad(base + 9, next + 9, next + 10, base + 10); // Right
                    quad(base + 10, next + 10, next + 11, base + 11); // Bottom
                    quad(base + 11, next + 11, next + 8, base + 8); // Left
                    
                    // Transition from neck to stem (fill the step)
                    // Top transition
                    quad(base + 8, next + 8, next + 12, base + 12);
                    // Right transition
                    quad(base + 9, next + 9, next + 13, base + 13);
                    // Bottom transition
                    quad(base + 10, next + 10, next + 14, base + 14);
                    // Left transition
                    quad(base + 11, next + 11, next + 15, base + 15);
                    
                    // Stem section (vertices 12-15)
                    quad(base + 12, next + 12, next + 13, base + 13); // Top
                    quad(base + 13, next + 13, next + 14, base + 14); // Right
                    quad(base + 14, next + 14, next + 15, base + 15); // Bottom
                    quad(base + 15, next + 15, next + 12, base + 12); // Left
                }

                // Cap the ends
                const capQuad = (a, b, c, d) => {
                    indices.push(a, b, c);
                    indices.push(a, c, d);
                };
                
                // Start cap (complex T-shape)
                const s = 0;
                capQuad(s + 0, s + 3, s + 7, s + 4); // Head left side
                capQuad(s + 4, s + 7, s + 11, s + 8); // Neck left side
                capQuad(s + 8, s + 11, s + 15, s + 12); // Stem left side
                capQuad(s + 12, s + 15, s + 14, s + 13); // Stem bottom
                capQuad(s + 13, s + 14, s + 10, s + 9); // Stem right + Neck right
                capQuad(s + 9, s + 10, s + 6, s + 5); // Neck right to Head right
                capQuad(s + 5, s + 6, s + 2, s + 1); // Head right side
                capQuad(s + 1, s + 2, s + 3, s + 0); // Head top
                capQuad(s + 0, s + 4, s + 8, s + 12); // Connect tops
                capQuad(s + 0, s + 12, s + 13, s + 1); // Top surface
                
                // End cap (reverse winding)
                const e = segments * vertsPerSegment;
                capQuad(e + 0, e + 4, e + 7, e + 3);
                capQuad(e + 4, e + 8, e + 11, e + 7);
                capQuad(e + 8, e + 12, e + 15, e + 11);
                capQuad(e + 12, e + 13, e + 14, e + 15);
                capQuad(e + 13, e + 9, e + 10, e + 14);
                capQuad(e + 9, e + 5, e + 6, e + 10);
                capQuad(e + 5, e + 1, e + 2, e + 6);
                capQuad(e + 1, e + 0, e + 3, e + 2);
                capQuad(e + 0, e + 12, e + 8, e + 4);
                capQuad(e + 0, e + 1, e + 13, e + 12);

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);
                geometry.computeVertexNormals();

                const mesh = new THREE.Mesh(geometry, material);
                return mesh;
            }

            // ========================================================================
            // BUILD GIMBAL
            // ========================================================================

            buildGimbal() {
                // Create geometries
                const frameGeometry = this.createFrameGeometry();
                const teardropGeometry = this.createTeardropShape();

                // Vertical system (Yin - White)
                this.frameYin = new THREE.Mesh(frameGeometry, this.materials.glass);
                this.frameYin.rotation.y = Math.PI / 2;
                this.scene.add(this.frameYin);

                this.rotorYin = new THREE.Group();
                const shapeYin = new THREE.Mesh(teardropGeometry, this.materials.yinWhite);
                this.rotorYin.add(shapeYin);
                this.rotorYin.add(this.createBearingArc(this.materials.yinRail));
                this.rotorYin.rotation.y = Math.PI / 2;
                this.scene.add(this.rotorYin);

                // Horizontal system (Yang - Black)
                this.frameYang = new THREE.Mesh(frameGeometry, this.materials.glass);
                this.frameYang.rotation.x = Math.PI / 2;
                this.frameYang.rotation.z = Math.PI / 2;
                this.scene.add(this.frameYang);

                this.rotorYang = new THREE.Group();
                this.shapeYang = new THREE.Mesh(teardropGeometry, this.materials.yangBlack);
                this.rotorYang.add(this.shapeYang);
                this.rotorYang.add(this.createBearingArc(this.materials.yangRail));
                this.rotorYang.rotation.x = Math.PI / 2;
                this.rotorYang.rotation.z = Math.PI / 2;
                this.scene.add(this.rotorYang);
            }

            // ========================================================================
            // CONTROLS & ANIMATION
            // ========================================================================

            initControls() {
                this.animationState = {
                    isPlaying: true,
                    time: 0
                };
                
                this.visibility = {
                    yinAssembly: true,
                    yangAssembly: true,
                    frame: true
                };
            }

            initAnimation() {
                this.animate = this.animate.bind(this);
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                this.orbitControls.update();

                if (this.animationState.isPlaying) {
                    this.animationState.time += CONFIG.rotationSpeed;
                    this.rotorYin.rotation.z = this.animationState.time;
                    this.rotorYang.rotation.z = this.animationState.time + Math.PI / 2;
                }

                this.renderer.render(this.scene, this.camera);
            }

            // ========================================================================
            // EXPORT FUNCTIONALITY
            // ========================================================================

            initExporter() {
                this.exporter = new STLExporter();
            }

            exportToSTL(object, filename) {
                const result = this.exporter.parse(object, { binary: true });
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            exportFrame() {
                const frameGeometry = this.createFrameGeometry();
                const frame = new THREE.Mesh(frameGeometry, this.materials.glass);
                this.exportToSTL(frame, 'gimbal_frame.stl');
            }

            exportYinRotor() {
                const group = new THREE.Group();
                const shape = new THREE.Mesh(this.createTeardropShape(), this.materials.yinWhite);
                group.add(shape);
                group.add(this.createBearingArc(this.materials.yinRail));
                this.exportToSTL(group, 'gimbal_yin_rotor.stl');
            }

            exportYangRotor() {
                const group = new THREE.Group();
                const shape = new THREE.Mesh(this.createTeardropShape(), this.materials.yangBlack);
                group.add(shape);
                group.add(this.createBearingArc(this.materials.yangRail));
                this.exportToSTL(group, 'gimbal_yang_rotor.stl');
            }

            // ========================================================================
            // EVENT HANDLERS
            // ========================================================================

            setupEventListeners() {
                // Controls toggle
                const controlsToggle = document.getElementById('controls-toggle');
                const controls = document.getElementById('controls');
                
                controlsToggle.addEventListener('click', () => {
                    controls.classList.toggle('collapsed');
                    controlsToggle.textContent = controls.classList.contains('collapsed') ? '☰' : '✕';
                });

                // Animation toggle
                document.getElementById('toggleAnimation').addEventListener('click', (e) => {
                    this.animationState.isPlaying = !this.animationState.isPlaying;
                    e.target.textContent = this.animationState.isPlaying ? 
                        'Pause Animation' : 'Resume Animation';
                });

                // Visibility toggles
                document.getElementById('toggleYin').addEventListener('click', (e) => {
                    this.visibility.yinAssembly = !this.visibility.yinAssembly;
                    this.rotorYin.visible = this.visibility.yinAssembly;
                    e.target.textContent = this.visibility.yinAssembly ? 'Hide Yin Assembly' : 'Show Yin Assembly';
                    e.target.className = this.visibility.yinAssembly ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                document.getElementById('toggleYang').addEventListener('click', (e) => {
                    this.visibility.yangAssembly = !this.visibility.yangAssembly;
                    this.rotorYang.visible = this.visibility.yangAssembly;
                    e.target.textContent = this.visibility.yangAssembly ? 'Hide Yang Assembly' : 'Show Yang Assembly';
                    e.target.className = this.visibility.yangAssembly ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                document.getElementById('toggleFrame').addEventListener('click', (e) => {
                    this.visibility.frame = !this.visibility.frame;
                    this.frameYin.visible = this.visibility.frame;
                    this.frameYang.visible = this.visibility.frame;
                    e.target.textContent = this.visibility.frame ? 'Hide Frame' : 'Show Frame';
                    e.target.className = this.visibility.frame ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                // Export buttons
                document.getElementById('exportFrame').addEventListener('click', () => {
                    this.exportFrame();
                });

                document.getElementById('exportYin').addEventListener('click', () => {
                    this.exportYinRotor();
                });

                document.getElementById('exportYang').addEventListener('click', () => {
                    this.exportYangRotor();
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        }

        // ============================================================================
        // INITIALIZE
        // ============================================================================

        const gimbal = new GimbalScene();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
n    <title>Yin Yang T-slot Gimbal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background-color: #222;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #ccc;
            pointer-events: none;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #info h1 {
            font-size: 2em;
            font-weight: 300;
            margin-bottom: 8px;
            color: #fff;
        }

        #info p {
            font-size: 0.9em;
            color: #aaa;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 12px;
            color: #fff;
            z-index: 10;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #controls.collapsed {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }

        #controls-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            color: #fff;
            font-size: 24px;
            cursor: pointer;
            z-index: 11;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #controls-toggle:hover {
            background: rgba(0, 0, 0, 0.85);
            border-color: rgba(255, 255, 255, 0.4);
            transform: scale(1.1);
        }

        .control-section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .control-section h3 {
            font-size: 0.85em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
            margin-bottom: 12px;
            font-weight: 600;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #ccc;
        }

        .value-display {
            color: #00ddff;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            cursor: pointer;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ddff;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #00ddff;
            cursor: pointer;
            border: none;
            transition: transform 0.2s;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        button {
            width: 100%;
            padding: 12px;
            margin-top: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: transparent;
        }

        button.primary:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        button.success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            border-color: transparent;
        }

        button.success:hover {
            background: linear-gradient(135deg, #38ef7d 0%, #11998e 100%);
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <button id="controls-toggle" title="Toggle Controls">☰</button>
    
    <div id="controls" class="collapsed">
        <div class="control-section">
            <h3>Animation</h3>
            <button id="toggleAnimation" class="primary">Pause Animation</button>
        </div>

        <div class="control-section">
            <h3>Visibility</h3>
            <button id="toggleYin" class="success">Hide Yin Assembly</button>
            <button id="toggleYang" class="success">Hide Yang Assembly</button>
            <button id="toggleFrame" class="success">Hide Frame</button>
        </div>

        <div class="control-section">
            <h3>3D Print Export</h3>
            <button id="exportFrame">Export Frame (STL)</button>
            <button id="exportYin">Export Yin Rotor (STL)</button>
            <button id="exportYang">Export Yang Rotor (STL)</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { STLExporter } from 'three/addons/exporters/STLExporter.js';

        // ============================================================================
        // CONFIGURATION
        // ============================================================================
        
        const CONFIG = {
            // Dimensions
            frameRadius: 4.0,
            shapeRadius: 3.65,
            shapeThickness: 0.15,
            centerHoleRadius: 0.35,
            
            // Frame profile - T-slot dimensions
            frameThickness: 0.4,       // Reduced from 0.8 - much thinner walls
            frameWidth: 0.5,           // Reduced from 0.8 - thinner profile
            tSlotMouthWidth: 0.3,      // Mouth opening (narrow part)
            tSlotChamberWidth: 0.5,    // Chamber width (wide part)
            tSlotChamberDepth: 0.3,    // How deep the chamber goes
            tSlotLipDepth: 0.08,       // Lip thickness before chamber
            
            // Bearing dimensions
            bearingHeadRadius: 0.10,
            bearingHeadHeight: 0.10,
            bearingNeckRadius: 0.06,
            bearingCount: 9,
            
            // Animation
            rotationSpeed: 0.015,
            
            // Geometry
            latheSegments: 128,
            cylinderSegments: 16,
            filletRadius: 0.15
        };

        // ============================================================================
        // SCENE SETUP
        // ============================================================================
        
        class GimbalScene {
            constructor() {
                this.initScene();
                this.initLights();
                this.initMaterials();
                this.buildGimbal();
                this.initControls();
                this.initAnimation();
                this.initExporter();
                this.setupEventListeners();
                this.animate();
            }

            initScene() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);

                // Camera - optimized near/far for better depth precision
                this.camera = new THREE.PerspectiveCamera(
                    45,
                    window.innerWidth / window.innerHeight,
                    1,
                    100
                );
                this.camera.position.set(12, 10, 12);

                // Renderer - enable logarithmic depth buffer to fix z-fighting
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    logarithmicDepthBuffer: true,
                    powerPreference: 'high-performance'
                });
                // Enable shadow map for better depth perception (helps reduce shimmer)
                this.renderer.shadowMap.enabled = false; // Keep disabled for performance
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2 to avoid over-sampling artifacts
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Orbit controls
                this.orbitControls = new OrbitControls(this.camera, this.renderer.domElement);
                this.orbitControls.enableDamping = true;
                this.orbitControls.dampingFactor = 0.05;
            }

            initLights() {
                // Ambient light - neutral white
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Main directional light - neutral white
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(5, 10, 5);
                this.scene.add(mainLight);

                // Fill light from opposite side - neutral white
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
                fillLight.position.set(-5, -3, -5);
                this.scene.add(fillLight);
            }

            initMaterials() {
                this.materials = {
                    glass: new THREE.MeshStandardMaterial({
                        color: 0xccddff,
                        metalness: 0.1,
                        roughness: 0.1,
                        transparent: true,
                        opacity: 0.15,
                        side: THREE.DoubleSide,
                        depthWrite: false,
                        premultipliedAlpha: true
                    }),
                    yinWhite: new THREE.MeshStandardMaterial({
                        color: 0xf0f0f0,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    }),
                    yangBlack: new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.9,
                        metalness: 0.0,
                        side: THREE.DoubleSide,
                        flatShading: false
                    }),
                    yinRail: new THREE.MeshStandardMaterial({
                        color: 0xf0f0f0,
                        roughness: 0.7,
                        metalness: 0.2,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 0.5,
                        polygonOffsetUnits: 0.5
                    }),
                    yangRail: new THREE.MeshStandardMaterial({
                        color: 0x1a1a1a,
                        roughness: 0.7,
                        metalness: 0.2,
                        side: THREE.DoubleSide,
                        flatShading: false,
                        polygonOffset: true,
                        polygonOffsetFactor: 0.5,
                        polygonOffsetUnits: 0.5
                    })
                };
            }

            // ========================================================================
            // GEOMETRY CREATION
            // ========================================================================

            createFrameGeometry() {
                const { frameRadius, frameThickness, frameWidth, 
                        tSlotMouthWidth, tSlotChamberWidth, 
                        tSlotChamberDepth, tSlotLipDepth, latheSegments } = CONFIG;

                const halfThick = frameThickness / 2;
                const halfWidth = frameWidth / 2;
                const cx = frameRadius;

                const hMouth = tSlotMouthWidth / 2;
                const hChamber = tSlotChamberWidth / 2;

                const xInner = cx - halfWidth;
                const xOuter = cx + halfWidth;
                const xChamberStart = xInner + tSlotLipDepth;
                const xChamberBack = xInner + tSlotChamberDepth;

                // Build T-slot profile
                const points = [
                    new THREE.Vector2(xInner, hMouth),
                    new THREE.Vector2(xChamberStart, hMouth),
                    new THREE.Vector2(xChamberStart, hChamber),
                    new THREE.Vector2(xChamberBack, hChamber),
                    new THREE.Vector2(xChamberBack, -hChamber),
                    new THREE.Vector2(xChamberStart, -hChamber),
                    new THREE.Vector2(xChamberStart, -hMouth),
                    new THREE.Vector2(xInner, -hMouth),
                    new THREE.Vector2(xInner, -halfThick),
                    new THREE.Vector2(xOuter, -halfThick),
                    new THREE.Vector2(xOuter, halfThick),
                    new THREE.Vector2(xInner, halfThick),
                    new THREE.Vector2(xInner, hMouth)
                ];

                const geometry = new THREE.LatheGeometry(points, latheSegments);
                geometry.rotateX(Math.PI / 2);

                return geometry;
            }

            createTeardropShape() {
                const { shapeRadius, centerHoleRadius, shapeThickness, filletRadius } = CONFIG;
                
                const R = shapeRadius;
                const r_hole = centerHoleRadius;
                const Rs = R / 2;
                const rf = filletRadius;

                const shape = new THREE.Shape();

                // Helper function for fillet calculations
                const getFilletData = (y1, d1, d2, intersectionSign) => {
                    const fy = (y1 * y1 - d1 * d1 + d2 * d2) / (2 * y1);
                    const fx = intersectionSign * Math.sqrt(d2 * d2 - fy * fy);
                    const angleFromC1 = Math.atan2(fy - y1, fx);
                    const angleFromC2 = Math.atan2(fy, fx);
                    return { fx, fy, angleFromC1, angleFromC2 };
                };

                // Calculate fillets
                const topFillet = getFilletData(Rs, Rs - rf, r_hole + rf, -1);
                const botFillet = getFilletData(-Rs, Rs + rf, r_hole + rf, 1);

                // Build the teardrop path
                shape.absarc(0, 0, R, -Math.PI / 2, Math.PI / 2, false);
                shape.absarc(0, Rs, Rs, Math.PI / 2, topFillet.angleFromC1, false);
                shape.absarc(topFillet.fx, topFillet.fy, rf, topFillet.angleFromC1, topFillet.angleFromC2 + Math.PI, false);
                shape.absarc(0, 0, r_hole, topFillet.angleFromC2, botFillet.angleFromC2, true);
                shape.absarc(botFillet.fx, botFillet.fy, rf, botFillet.angleFromC2 + Math.PI, botFillet.angleFromC1 + Math.PI, false);
                shape.absarc(0, -Rs, Rs, botFillet.angleFromC1, -Math.PI / 2, true);

                // Add the "dot" hole
                const dotRadius = Rs / 3.5;
                const dotPath = new THREE.Path();
                dotPath.absarc(0, Rs, dotRadius, 0, Math.PI * 2, true);
                shape.holes.push(dotPath);

                // Extrude the shape
                const geometry = new THREE.ExtrudeGeometry(shape, {
                    depth: shapeThickness,
                    bevelEnabled: false
                });
                geometry.translate(0, 0, -shapeThickness / 2);

                return geometry;
            }

            createBearingArc(material) {
                const { frameRadius, shapeRadius, tSlotMouthWidth, tSlotChamberWidth, shapeThickness } = CONFIG;

                // Simplified T-rail using separate components to avoid shimmering
                const clearance = 0.02;
                const group = new THREE.Group();
                
                // Arc parameters
                const startAngle = -Math.PI / 2 + Math.PI / 18;
                const endAngle = Math.PI / 2 - Math.PI / 18;
                const segments = 128; // Reduced segments for cleaner geometry
                
                // Dimensions
                const headWidth = tSlotChamberWidth - clearance;
                const headHeight = 0.25;
                const headDepth = 0.15;
                
                const neckWidth = tSlotMouthWidth - clearance;
                const neckHeight = shapeThickness;
                const neckDepth = 0.12;
                
                const stemWidth = shapeThickness;
                const stemHeight = shapeThickness;
                const totalRailDepth = (frameRadius - shapeRadius) + 0.05;
                const stemDepth = totalRailDepth - neckDepth - headDepth;
                
                // Create curve path for the arc
                const curve = new THREE.EllipseCurve(
                    0, 0,            // center
                    frameRadius, frameRadius,  // x radius, y radius
                    startAngle, endAngle,      // start angle, end angle
                    false,           // clockwise
                    0                // rotation
                );
                
                const points = curve.getPoints(segments);
                const curvePath = new THREE.CatmullRomCurve3(
                    points.map(p => new THREE.Vector3(p.x, p.y, 0))
                );
                
                // Create three separate tubes for head, neck, and stem
                // This avoids the complex geometry that causes shimmering
                
                // HEAD - wide and tall
                const headShape = new THREE.Shape();
                headShape.moveTo(-headWidth/2, -headHeight/2);
                headShape.lineTo(headWidth/3, -headHeight/2);
                headShape.lineTo(headWidth/2, headHeight/2);
                headShape.lineTo(-headWidth/2, headHeight/2);
                headShape.lineTo(-headWidth/2, -headHeight/2);
                
                const headGeom = new THREE.ExtrudeGeometry(headShape, {
                    extrudePath: curvePath,
                    steps: segments,
                    bevelEnabled: false
                });
                
                // Offset head radially outward
                const headMesh = new THREE.Mesh(headGeom, material);
                headMesh.position.set(0, 0, 0);
                
                // Scale head to correct depth
                const headScaleFactor = headDepth / frameRadius;
                headMesh.scale.set(1 - headScaleFactor/2, 1 - headScaleFactor/2, 1);
                
                group.add(headMesh);
                
                // NECK - narrow and thin
                const neckShape = new THREE.Shape();
                neckShape.moveTo(-neckWidth/2, -neckHeight/2);
                neckShape.lineTo(neckWidth/2, -neckHeight/2);
                neckShape.lineTo(neckWidth/2, neckHeight/2);
                neckShape.lineTo(-neckWidth/2, neckHeight/2);
                neckShape.lineTo(-neckWidth/2, -neckHeight/2);
                
                const neckGeom = new THREE.ExtrudeGeometry(neckShape, {
                    extrudePath: curvePath,
                    steps: segments,
                    bevelEnabled: false
                });
                
                const neckMesh = new THREE.Mesh(neckGeom, material);
                const neckScaleFactor = (headDepth + neckDepth) / frameRadius;
                neckMesh.scale.set(1 - neckScaleFactor/2, 1 - neckScaleFactor/2, 1);
                
                group.add(neckMesh);
                
                // STEM - thin connection to rotor
                const stemShape = new THREE.Shape();
                stemShape.moveTo(-stemWidth/2, -stemHeight/2);
                stemShape.lineTo(stemWidth/2, -stemHeight/2);
                stemShape.lineTo(stemWidth/2, stemHeight/2);
                stemShape.lineTo(-stemWidth/2, stemHeight/2);
                stemShape.lineTo(-stemWidth/2, -stemHeight/2);
                
                const stemGeom = new THREE.ExtrudeGeometry(stemShape, {
                    extrudePath: curvePath,
                    steps: segments,
                    bevelEnabled: false
                });
                
                const stemMesh = new THREE.Mesh(stemGeom, material);
                const stemScaleFactor = totalRailDepth / frameRadius;
                stemMesh.scale.set(1 - stemScaleFactor/2, 1 - stemScaleFactor/2, 1);
                
                group.add(stemMesh);
                
                return group;
            }

            // ========================================================================
            // BUILD GIMBAL
            // ========================================================================

            buildGimbal() {
                // Create geometries
                const frameGeometry = this.createFrameGeometry();
                const teardropGeometry = this.createTeardropShape();

                // Vertical system (Yin - White)
                this.frameYin = new THREE.Mesh(frameGeometry, this.materials.glass);
                this.frameYin.rotation.y = Math.PI / 2;
                this.frameYin.renderOrder = 999; // Render transparent frames last
                this.scene.add(this.frameYin);

                this.rotorYin = new THREE.Group();
                const shapeYin = new THREE.Mesh(teardropGeometry, this.materials.yinWhite);
                this.rotorYin.add(shapeYin);
                this.rotorYin.add(this.createBearingArc(this.materials.yinRail));
                this.rotorYin.rotation.y = Math.PI / 2;
                this.scene.add(this.rotorYin);

                // Horizontal system (Yang - Black)
                this.frameYang = new THREE.Mesh(frameGeometry, this.materials.glass);
                this.frameYang.rotation.x = Math.PI / 2;
                this.frameYang.rotation.z = Math.PI / 2;
                this.frameYang.renderOrder = 999; // Render transparent frames last
                this.scene.add(this.frameYang);

                this.rotorYang = new THREE.Group();
                this.shapeYang = new THREE.Mesh(teardropGeometry, this.materials.yangBlack);
                this.rotorYang.add(this.shapeYang);
                this.rotorYang.add(this.createBearingArc(this.materials.yangRail));
                this.rotorYang.rotation.x = Math.PI / 2;
                this.rotorYang.rotation.z = Math.PI / 2;
                this.scene.add(this.rotorYang);
            }

            // ========================================================================
            // CONTROLS & ANIMATION
            // ========================================================================

            initControls() {
                this.animationState = {
                    isPlaying: true,
                    time: 0
                };
                
                this.visibility = {
                    yinAssembly: true,
                    yangAssembly: true,
                    frame: true
                };
            }

            initAnimation() {
                this.animate = this.animate.bind(this);
            }

            animate() {
                requestAnimationFrame(this.animate);
                
                this.orbitControls.update();

                if (this.animationState.isPlaying) {
                    this.animationState.time += CONFIG.rotationSpeed;
                    this.rotorYin.rotation.z = this.animationState.time;
                    this.rotorYang.rotation.z = this.animationState.time + Math.PI / 2;
                }

                this.renderer.render(this.scene, this.camera);
            }

            // ========================================================================
            // EXPORT FUNCTIONALITY
            // ========================================================================

            initExporter() {
                this.exporter = new STLExporter();
            }

            exportToSTL(object, filename) {
                const result = this.exporter.parse(object, { binary: true });
                const blob = new Blob([result], { type: 'application/octet-stream' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                link.click();
                URL.revokeObjectURL(link.href);
            }

            exportFrame() {
                const frameGeometry = this.createFrameGeometry();
                
                // Create both rings with proper rotations
                // Vertical ring (Yin frame)
                const frameYinGeom = frameGeometry.clone();
                frameYinGeom.rotateY(Math.PI / 2);
                
                // Horizontal ring (Yang frame)
                const frameYangGeom = frameGeometry.clone();
                frameYangGeom.rotateX(Math.PI / 2);
                frameYangGeom.rotateZ(Math.PI / 2);
                
                // Merge both geometries into one
                const mergedGeometry = new THREE.BufferGeometry();
                const geometries = [frameYinGeom, frameYangGeom];
                
                // Manually merge the geometries
                let totalVertices = 0;
                let totalIndices = 0;
                
                for (const geom of geometries) {
                    totalVertices += geom.attributes.position.count;
                    if (geom.index) {
                        totalIndices += geom.index.count;
                    }
                }
                
                const positions = new Float32Array(totalVertices * 3);
                const normals = new Float32Array(totalVertices * 3);
                const indices = new Uint32Array(totalIndices);
                
                let vertexOffset = 0;
                let indexOffset = 0;
                let vertexCount = 0;
                
                for (const geom of geometries) {
                    const posAttr = geom.attributes.position;
                    const normAttr = geom.attributes.normal;
                    
                    positions.set(posAttr.array, vertexOffset * 3);
                    if (normAttr) {
                        normals.set(normAttr.array, vertexOffset * 3);
                    }
                    
                    if (geom.index) {
                        const indexArray = geom.index.array;
                        for (let i = 0; i < indexArray.length; i++) {
                            indices[indexOffset + i] = indexArray[i] + vertexCount;
                        }
                        indexOffset += indexArray.length;
                    }
                    
                    vertexCount += posAttr.count;
                    vertexOffset += posAttr.count;
                }
                
                mergedGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 4));
                mergedGeometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
                mergedGeometry.setIndex(new THREE.BufferAttribute(indices, 1));
                
                const frameMesh = new THREE.Mesh(mergedGeometry, this.materials.glass);
                this.exportToSTL(frameMesh, 'gimbal_frame.stl');
            }

            exportYinRotor() {
                const group = new THREE.Group();
                const shape = new THREE.Mesh(this.createTeardropShape(), this.materials.yinWhite);
                group.add(shape);
                group.add(this.createBearingArc(this.materials.yinRail));
                this.exportToSTL(group, 'gimbal_yin_rotor.stl');
            }

            exportYangRotor() {
                const group = new THREE.Group();
                const shape = new THREE.Mesh(this.createTeardropShape(), this.materials.yangBlack);
                group.add(shape);
                group.add(this.createBearingArc(this.materials.yangRail));
                this.exportToSTL(group, 'gimbal_yang_rotor.stl');
            }

            // ========================================================================
            // EVENT HANDLERS
            // ========================================================================

            setupEventListeners() {
                // Controls toggle
                const controlsToggle = document.getElementById('controls-toggle');
                const controls = document.getElementById('controls');
                
                controlsToggle.addEventListener('click', () => {
                    controls.classList.toggle('collapsed');
                    controlsToggle.textContent = controls.classList.contains('collapsed') ? '☰' : '✕';
                });

                // Animation toggle
                document.getElementById('toggleAnimation').addEventListener('click', (e) => {
                    this.animationState.isPlaying = !this.animationState.isPlaying;
                    e.target.textContent = this.animationState.isPlaying ? 
                        'Pause Animation' : 'Resume Animation';
                });

                // Visibility toggles
                document.getElementById('toggleYin').addEventListener('click', (e) => {
                    this.visibility.yinAssembly = !this.visibility.yinAssembly;
                    this.rotorYin.visible = this.visibility.yinAssembly;
                    e.target.textContent = this.visibility.yinAssembly ? 'Hide Yin Assembly' : 'Show Yin Assembly';
                    e.target.className = this.visibility.yinAssembly ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                document.getElementById('toggleYang').addEventListener('click', (e) => {
                    this.visibility.yangAssembly = !this.visibility.yangAssembly;
                    this.rotorYang.visible = this.visibility.yangAssembly;
                    e.target.textContent = this.visibility.yangAssembly ? 'Hide Yang Assembly' : 'Show Yang Assembly';
                    e.target.className = this.visibility.yangAssembly ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                document.getElementById('toggleFrame').addEventListener('click', (e) => {
                    this.visibility.frame = !this.visibility.frame;
                    this.frameYin.visible = this.visibility.frame;
                    this.frameYang.visible = this.visibility.frame;
                    e.target.textContent = this.visibility.frame ? 'Hide Frame' : 'Show Frame';
                    e.target.className = this.visibility.frame ? 'success' : '';
                    if (!this.animationState.isPlaying) this.renderer.render(this.scene, this.camera);
                });

                // Export buttons
                document.getElementById('exportFrame').addEventListener('click', () => {
                    this.exportFrame();
                });

                document.getElementById('exportYin').addEventListener('click', () => {
                    this.exportYinRotor();
                });

                document.getElementById('exportYang').addEventListener('click', () => {
                    this.exportYangRotor();
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        }

        // ============================================================================
        // INITIALIZE
        // ============================================================================

        const gimbal = new GimbalScene();
    </script>
</body>
</html>

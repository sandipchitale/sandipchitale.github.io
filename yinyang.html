<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Yin Yang Gimbal Visualization</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #1a1a1a;
        font-family: "Inter", sans-serif;
        color: #ffffff;
      }
      #info {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 20px;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        pointer-events: auto;
      }
      h1 {
        margin: 0 0 15px 0;
        font-size: 1.2rem;
        font-weight: 600;
        letter-spacing: 0.5px;
      }
      .control-group {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .control-item {
        display: flex;
        align-items: center;
        gap: 10px;
        cursor: pointer;
      }
      input[type="checkbox"] {
        accent-color: #4caf50;
        width: 18px;
        height: 18px;
        cursor: pointer;
      }
      label {
        font-size: 0.9rem;
        cursor: pointer;
        user-select: none;
      }
      #status {
        margin-top: 15px;
        font-size: 0.8rem;
        color: #888;
        font-style: italic;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.5rem;
        font-weight: bold;
        color: #4caf50;
        pointer-events: none;
      }
    </style>
    <!-- Import maps polyfill -->
    <script
      async
      src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"
    ></script>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <div id="loading">Loading Models...</div>
    <div id="info">
      <h1>Yin Yang Gimbal</h1>
      <div class="control-group">
        <div class="control-item">
          <input type="checkbox" id="toggle-enclosure" />
          <label for="toggle-enclosure">Show Glass Shells</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-gears" checked />
          <label for="toggle-gears">Show Gears</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-yin" checked />
          <label for="toggle-yin">Show Yin Rail</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-yang" checked />
          <label for="toggle-yang">Show Yang Rail</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-frame-left" checked />
          <label for="toggle-frame-left">Show Left Frame</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-frame-right" checked />
          <label for="toggle-frame-right">Show Right Frame</label>
        </div>
        <div class="control-item">
          <input type="checkbox" id="toggle-anim" checked />
          <label for="toggle-anim">Animate (Click Model to Toggle)</label>
        </div>
      </div>
      <div id="status">Click anywhere on the model to pause/resume.</div>
    </div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { STLLoader } from "three/addons/loaders/STLLoader.js";

      // Scene Setup
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a1a);
      // Add some fog for depth
      scene.fog = new THREE.Fog(0x1a1a1a, 20, 100);

      const camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(30, 20, 30);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Controls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lighting
      const ambientLight = new THREE.AmbientLight(0x404040, 2); // Soft white light
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 2);
      dirLight.position.set(10, 20, 10);
      scene.add(dirLight);

      const backLight = new THREE.DirectionalLight(0x445566, 1);
      backLight.position.set(-10, 5, -10);
      scene.add(backLight);

      // Materials
      const materialYin = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        roughness: 0.4,
        metalness: 0.1,
      });
      const materialYang = new THREE.MeshStandardMaterial({
        color: 0x222222,
        roughness: 0.4,
        metalness: 0.1,
      });
      const materialGlass = new THREE.MeshPhysicalMaterial({
        color: 0xffffff,
        metalness: 0,
        roughness: 0.1,
        transmission: 0.9, // Glass-like
        thickness: 1.5,
        transparent: true,
        opacity: 0.3, // Very transparent
        side: THREE.DoubleSide,
      });
      const materialFrame = new THREE.MeshStandardMaterial({
        color: 0x888888,
        roughness: 0.7,
        metalness: 0.5,
      });
      const materialGears = new THREE.MeshStandardMaterial({
        color: 0xffffff, // White color for gears
        roughness: 0.3,
        metalness: 0.8,
      });

      // Groups for rotation
      const yinGroup = new THREE.Group();
      const yangGroup = new THREE.Group();
      const frameGroup = new THREE.Group();
      // Gears group will contain all gears
      // But we need to actuate them.
      // 16 gears total.
      // 8 drive Yin (Z-axis rotation dependent).
      // 8 drive Yang (Y-axis rotation dependent).
      // We should separate them into sub-groups for easier animation?
      // Since they are all in one STL 'gears.stl', they are merged.
      // This makes individual rotation hard!
      // Ah. If I merged them in TS using union(gears), they are one mesh.
      // I cannot rotate them individually in Three.js if they are one STL.

      // CRITICAL FIX:
      // I should NOT merge gears in TS if I want to animate them individually.
      // But STLLoader loads one file.
      // If I want to animate them, I must load them separately OR export them separately?
      // Or 16 files? 'gear_0.stl' ... 'gear_15.stl'.
      // That's too many files.
      // Alternative: Export ONE gear.stl (centered).
      // Then in Three.js, instantiate 16 Meshes, position them, and animate them.

      // I will update yinyang.ts to export a SINGLE gear.
      // And in HTML I will replicate the positioning logic.
      // This is better for runtime performance (instancing) and animation.

      // Reverting this thoughts: I will modify yinyang.ts to export 'gear.stl'.
      // Then in HTML I implement the placement logic.

      // Start of HTML update assuming 'gear.stl' is available.

      const gearsGroup = new THREE.Group();

      scene.add(yinGroup);
      scene.add(yangGroup);
      scene.add(frameGroup);
      scene.add(gearsGroup);

      // Loaders
      const loader = new STLLoader();
      let loadedCount = 0;
      const totalModels = 5; // yin, yang, frame_l, frame_r, glass, gear (wait, that's 6)

      function checkLoaded() {
        loadedCount++;
        if (loadedCount === totalModels) {
          document.getElementById("loading").style.display = "none";
          animate();
        }
      }

      // Helper to load STL
      function loadSTL(path, material, group, name, visible = true) {
        loader.load(
          path,
          function (geometry) {
            geometry.computeVertexNormals();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.name = name;
            mesh.visible = visible;
            group.add(mesh);
            checkLoaded();
          },
          undefined,
          function (error) {
            console.error("Error loading " + path, error);
            // Don't hang if file missing
            checkLoaded();
          }
        );
      }

      // Gears separate loader because we need to clone it
      function loadGears() {
        loader.load(
          "./gear.stl",
          function (geometry) {
            geometry.computeVertexNormals();

            const RADIUS = 10;
            const STEM = 0.6;
            const HEAD = 0.2;
            const HEAD_THICKNESS = 0.2;
            const HEAD_WIDTH = 0.8;

            const GEAR_MODULE = 0.1;
            const GEAR_COUNT = 24; // Updated to 24
            const GEAR_PITCH_R = (GEAR_COUNT * GEAR_MODULE) / 2;

            const offset = HEAD_WIDTH / 2 + GEAR_PITCH_R;
            const headCenterR = RADIUS + STEM + HEAD_THICKNESS / 2;

            const corners = [-1, 1];

            // Helper to add gear
            const addGear = (pos, dir, rotationY) => {
              const mesh = new THREE.Mesh(geometry, materialGears);

              // Base Axis Z. Rotate Y to align with Radial line (X).
              // If Right (+X): Rotate +90 (Z -> +X).
              // If Left (-X): Rotate -90 (Z -> -X).
              mesh.rotation.y = rotationY;

              mesh.position.set(pos[0], pos[1], pos[2]);

              mesh.userData = { direction: dir };
              gearsGroup.add(mesh);
            };

            [RADIUS, -RADIUS].forEach((xBase) => {
              const xSign = Math.sign(xBase);

              // Rotate to face Outward:
              // Right (+X) -> +PI/2
              // Left (-X) -> -PI/2
              const rotY = (xSign * Math.PI) / 2;

              corners.forEach((ySign) => {
                corners.forEach((zSign) => {
                  // Filter Gears to match Model (Keep Anti-Diagonal Pairs)
                  if (ySign === zSign) return;

                  const yLocal = ySign * offset;
                  const zLocal = zSign * offset;

                  const xSq = headCenterR * headCenterR - yLocal * yLocal;
                  const x =
                    xSq > 0 ? xSign * Math.sqrt(xSq) : xSign * headCenterR;

                  // Calculate Direction
                  // User requested Opposite Direction for Far Side (xSign < 0).
                  // Combined with previous "Opposite" logic:
                  // Near (x>0): -1 * xSign * ySign = -ySign.
                  // Far (x<0): Original was -1 * xSign * ySign = ySign.
                  // Flip Far -> -ySign.
                  // Result: dir = -1 * ySign.
                  const dir = -1 * ySign;

                  addGear([x, yLocal, zLocal], dir, rotY);
                });
              });
            });

            checkLoaded();
          },
          undefined,
          (err) => {
            console.error(err);
            checkLoaded();
          }
        );
      }

      // Load Models
      loadSTL("./yin.stl", materialYin, yinGroup, "yin");
      loadSTL("./yang.stl", materialYang, yangGroup, "yang");
      loadSTL("./frame_left.stl", materialFrame, frameGroup, "frame_left");
      loadSTL("./frame_right.stl", materialFrame, frameGroup, "frame_right");
      // Load glass panels but hide initially as requested
      loadSTL(
        "./glass_panels.stl",
        materialGlass,
        frameGroup,
        "glass_panels",
        false
      );
      loadGears();

      // Update totalModels count to 6
      const totalModelsExpected = 6;

      // Animation State
      let isAnimating = true;
      // Reduced speed to prevent "Wagon-wheel effect" where teeth appear to rotate backwards
      // Tooth Pitch = 2*PI/24 = 0.26 rad.
      // GearRatio = 16.
      // Old Speed 0.01 * 16 = 0.16 rad (> 0.5 pitch). Caused aliasing.
      // New Speed 0.002 * 16 = 0.032 rad (Well within Nyquist limit).
      const rotationSpeed = 0.002;
      const gearRatio = 16;

      // UI Logic
      const toggleVisibility = (id, objectName) => {
        const el = document.getElementById(id);
        if (!el) {
          console.error(`Element with id ${id} not found!`);
          return;
        }
        el.addEventListener("change", (e) => {
          if (objectName === "yin") {
            yinGroup.visible = e.target.checked;
          } else if (objectName === "yang") {
            yangGroup.visible = e.target.checked;
          } else {
            const mesh = frameGroup.children.find((c) => c.name === objectName);
            if (mesh) {
              mesh.visible = e.target.checked;
            } else {
              if (objectName === "gears") {
                gearsGroup.visible = e.target.checked;
              }
            }
          }
        });
      };

      toggleVisibility("toggle-frame-left", "frame_left");
      toggleVisibility("toggle-frame-right", "frame_right");
      toggleVisibility("toggle-enclosure", "glass_panels");
      toggleVisibility("toggle-gears", "gears");
      toggleVisibility("toggle-yin", "yin");
      toggleVisibility("toggle-yang", "yang");

      const animToggle = document.getElementById("toggle-anim");
      animToggle.addEventListener("change", (e) => {
        isAnimating = e.target.checked;
        document.getElementById("status").textContent = isAnimating
          ? "Animation running..."
          : "Animation paused.";
      });

      // Click to toggle
      window.addEventListener("mousedown", (event) => {
        if (event.target.closest("#info")) return;

        isAnimating = !isAnimating;
        animToggle.checked = isAnimating;
        document.getElementById("status").textContent = isAnimating
          ? "Animation running..."
          : "Animation paused.";
      });

      // Resize Handler
      window.addEventListener("resize", onWindowResize, false);
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Animation Loop
      function animate() {
        requestAnimationFrame(animate);

        if (isAnimating) {
          // Rail Rotation
          yinGroup.rotation.z += rotationSpeed;
          yangGroup.rotation.y = -yinGroup.rotation.z;

          // Gear Rotation
          // Gears are axis-aligned to X.
          // Rotation direction determined by Q2/Q4 logic.
          // Q2 (ySign < 0) -> -speed.
          // Q4 (ySign > 0) -> +speed.

          const speed = rotationSpeed * gearRatio;

          gearsGroup.children.forEach((gear) => {
            const dir = gear.userData.direction;
            // Local X rotation (since we rotated Y 90, Local Z is World X? No.)
            // mesh.rotation.y = PI/2.
            // Local Order XYZ default.
            // Local X axis points World Z.
            // Local Y axis points World Y.
            // Local Z axis points World X.
            // We want to rotate around World X (Gear Axis).
            // So we rotate around Local Z.
            // Wait.
            // Base Gear Axis is Z.
            // We rotated Y 90.
            // New Z axis points in World X direction.
            // So rotating around Local Z rotates around World X.
            // Correct.

            gear.rotateZ(dir * speed);
          });
        }

        controls.update();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
